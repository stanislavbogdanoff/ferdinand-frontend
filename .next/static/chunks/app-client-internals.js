/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app-client-internals"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5CHP%5CDesktop%5Cferdinand-frontend%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Capp-router.js&modules=C%3A%5CUsers%5CHP%5CDesktop%5Cferdinand-frontend%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Clayout-router.js&modules=C%3A%5CUsers%5CHP%5CDesktop%5Cferdinand-frontend%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Crender-from-template-context.js&server=false!":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5CHP%5CDesktop%5Cferdinand-frontend%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Capp-router.js&modules=C%3A%5CUsers%5CHP%5CDesktop%5Cferdinand-frontend%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Clayout-router.js&modules=C%3A%5CUsers%5CHP%5CDesktop%5Cferdinand-frontend%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Crender-from-template-context.js&server=false! ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/app-router.js */ \"./node_modules/next/dist/client/components/app-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/layout-router.js */ \"./node_modules/next/dist/client/components/layout-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/render-from-template-context.js */ \"./node_modules/next/dist/client/components/render-from-template-context.js\", 23))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9QyUzQSU1Q1VzZXJzJTVDSFAlNUNEZXNrdG9wJTVDZmVyZGluYW5kLWZyb250ZW5kJTVDbm9kZV9tb2R1bGVzJTVDbmV4dCU1Q2Rpc3QlNUNjbGllbnQlNUNjb21wb25lbnRzJTVDYXBwLXJvdXRlci5qcyZtb2R1bGVzPUMlM0ElNUNVc2VycyU1Q0hQJTVDRGVza3RvcCU1Q2ZlcmRpbmFuZC1mcm9udGVuZCU1Q25vZGVfbW9kdWxlcyU1Q25leHQlNUNkaXN0JTVDY2xpZW50JTVDY29tcG9uZW50cyU1Q2xheW91dC1yb3V0ZXIuanMmbW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNIUCU1Q0Rlc2t0b3AlNUNmZXJkaW5hbmQtZnJvbnRlbmQlNUNub2RlX21vZHVsZXMlNUNuZXh0JTVDZGlzdCU1Q2NsaWVudCU1Q2NvbXBvbmVudHMlNUNyZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzJnNlcnZlcj1mYWxzZSEuanMiLCJtYXBwaW5ncyI6IkFBQUEsNE5BQTRJO0FBQzVJLGtPQUErSTtBQUMvSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2ZiZDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFxIUFxcXFxEZXNrdG9wXFxcXGZlcmRpbmFuZC1mcm9udGVuZFxcXFxub2RlX21vZHVsZXNcXFxcbmV4dFxcXFxkaXN0XFxcXGNsaWVudFxcXFxjb21wb25lbnRzXFxcXGFwcC1yb3V0ZXIuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXEhQXFxcXERlc2t0b3BcXFxcZmVyZGluYW5kLWZyb250ZW5kXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcbGF5b3V0LXJvdXRlci5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcSFBcXFxcRGVza3RvcFxcXFxmZXJkaW5hbmQtZnJvbnRlbmRcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjbGllbnRcXFxcY29tcG9uZW50c1xcXFxyZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzXCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5CHP%5CDesktop%5Cferdinand-frontend%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Capp-router.js&modules=C%3A%5CUsers%5CHP%5CDesktop%5Cferdinand-frontend%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Clayout-router.js&modules=C%3A%5CUsers%5CHP%5CDesktop%5Cferdinand-frontend%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Crender-from-template-context.js&server=false!\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/app-router-headers.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router-headers.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FLIGHT_PARAMETERS = exports.RSC_VARY_HEADER = exports.NEXT_ROUTER_PREFETCH = exports.NEXT_ROUTER_STATE_TREE = exports.RSC = void 0;\nvar RSC = 'RSC';\nexports.RSC = RSC;\nvar NEXT_ROUTER_STATE_TREE = 'Next-Router-State-Tree';\nexports.NEXT_ROUTER_STATE_TREE = NEXT_ROUTER_STATE_TREE;\nvar NEXT_ROUTER_PREFETCH = 'Next-Router-Prefetch';\nexports.NEXT_ROUTER_PREFETCH = NEXT_ROUTER_PREFETCH;\nvar RSC_VARY_HEADER = \"\".concat(RSC, \", \").concat(NEXT_ROUTER_STATE_TREE, \", \").concat(NEXT_ROUTER_PREFETCH);\nexports.RSC_VARY_HEADER = RSC_VARY_HEADER;\nvar FLIGHT_PARAMETERS = [[RSC], [NEXT_ROUTER_STATE_TREE], [NEXT_ROUTER_PREFETCH]];\nexports.FLIGHT_PARAMETERS = FLIGHT_PARAMETERS;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXItaGVhZGVycy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0M7QUFHQUQseUJBQUEsR0FBNEJBLHVCQUFBLEdBQTBCQSw0QkFBQSxHQUErQkEsOEJBQUEsR0FBaUNBLFdBQUEsR0FBYyxLQUFLLENBQXpJO0FBQ0EsSUFBTU0sR0FBRyxHQUFHLEtBQVo7QUFDQU4sV0FBQSxHQUFjTSxHQUFkO0FBQ0EsSUFBTUQsc0JBQXNCLEdBQUcsd0JBQS9CO0FBQ0FMLDhCQUFBLEdBQWlDSyxzQkFBakM7QUFDQSxJQUFNRCxvQkFBb0IsR0FBRyxzQkFBN0I7QUFDQUosNEJBQUEsR0FBK0JJLG9CQUEvQjtBQUNBLElBQU1ELGVBQWUsYUFBTUcsR0FBTixlQUFjRCxzQkFBZCxlQUF5Q0Qsb0JBQXpDLENBQXJCO0FBQ0FKLHVCQUFBLEdBQTBCRyxlQUExQjtBQUNBLElBQU1ELGlCQUFpQixHQUFHLENBQ3RCLENBQ0lJLEdBREosQ0FEc0IsRUFJdEIsQ0FDSUQsc0JBREosQ0FKc0IsRUFPdEIsQ0FDSUQsb0JBREosQ0FQc0IsQ0FBMUI7QUFXQUoseUJBQUEsR0FBNEJFLGlCQUE1Qjs7QUFFQSxJQUFJLENBQUMsT0FBT0YsT0FBTyxXQUFkLEtBQTJCLFVBQTNCLElBQTBDLE9BQU9BLE9BQU8sV0FBZCxLQUEyQixRQUEzQixJQUF1Q0EsT0FBTyxXQUFQLEtBQW9CLElBQXRHLEtBQWdILE9BQU9BLE9BQU8sV0FBUCxDQUFnQk8sVUFBdkIsS0FBc0MsV0FBMUosRUFBdUs7RUFDcktULE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsT0FBTyxXQUE3QixFQUF1QyxZQUF2QyxFQUFxRDtJQUFFQyxLQUFLLEVBQUU7RUFBVCxDQUFyRDtFQUNBSCxNQUFNLENBQUNVLE1BQVAsQ0FBY1IsT0FBTyxXQUFyQixFQUErQkEsT0FBL0I7RUFDQVMsTUFBTSxDQUFDVCxPQUFQLEdBQWlCQSxPQUFPLFdBQXhCO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLWhlYWRlcnMuanM/MzU2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRkxJR0hUX1BBUkFNRVRFUlMgPSBleHBvcnRzLlJTQ19WQVJZX0hFQURFUiA9IGV4cG9ydHMuTkVYVF9ST1VURVJfUFJFRkVUQ0ggPSBleHBvcnRzLk5FWFRfUk9VVEVSX1NUQVRFX1RSRUUgPSBleHBvcnRzLlJTQyA9IHZvaWQgMDtcbmNvbnN0IFJTQyA9ICdSU0MnO1xuZXhwb3J0cy5SU0MgPSBSU0M7XG5jb25zdCBORVhUX1JPVVRFUl9TVEFURV9UUkVFID0gJ05leHQtUm91dGVyLVN0YXRlLVRyZWUnO1xuZXhwb3J0cy5ORVhUX1JPVVRFUl9TVEFURV9UUkVFID0gTkVYVF9ST1VURVJfU1RBVEVfVFJFRTtcbmNvbnN0IE5FWFRfUk9VVEVSX1BSRUZFVENIID0gJ05leHQtUm91dGVyLVByZWZldGNoJztcbmV4cG9ydHMuTkVYVF9ST1VURVJfUFJFRkVUQ0ggPSBORVhUX1JPVVRFUl9QUkVGRVRDSDtcbmNvbnN0IFJTQ19WQVJZX0hFQURFUiA9IGAke1JTQ30sICR7TkVYVF9ST1VURVJfU1RBVEVfVFJFRX0sICR7TkVYVF9ST1VURVJfUFJFRkVUQ0h9YDtcbmV4cG9ydHMuUlNDX1ZBUllfSEVBREVSID0gUlNDX1ZBUllfSEVBREVSO1xuY29uc3QgRkxJR0hUX1BBUkFNRVRFUlMgPSBbXG4gICAgW1xuICAgICAgICBSU0NcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTkVYVF9ST1VURVJfU1RBVEVfVFJFRVxuICAgIF0sXG4gICAgW1xuICAgICAgICBORVhUX1JPVVRFUl9QUkVGRVRDSFxuICAgIF0sIFxuXTtcbmV4cG9ydHMuRkxJR0hUX1BBUkFNRVRFUlMgPSBGTElHSFRfUEFSQU1FVEVSUztcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlci1oZWFkZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZMSUdIVF9QQVJBTUVURVJTIiwiUlNDX1ZBUllfSEVBREVSIiwiTkVYVF9ST1VURVJfUFJFRkVUQ0giLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFIiwiUlNDIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/app-router-headers.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/app-router.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\"use client\";\n\"use strict\";\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _regeneratorRuntime = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js */ \"./node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js\");\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = AppRouter;\nexports.fetchServerResponse = fetchServerResponse;\n\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\n\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\n\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\n\nvar _client = __webpack_require__(/*! next/dist/compiled/react-server-dom-webpack/client */ \"./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\n\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\n\nvar _reducer = __webpack_require__(/*! ./reducer */ \"./node_modules/next/dist/client/components/reducer.js\");\n\nvar _hooksClientContext = __webpack_require__(/*! ../../shared/lib/hooks-client-context */ \"./node_modules/next/dist/shared/lib/hooks-client-context.js\");\n\nvar _useReducerWithDevtools = __webpack_require__(/*! ./use-reducer-with-devtools */ \"./node_modules/next/dist/client/components/use-reducer-with-devtools.js\");\n\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"./node_modules/next/dist/client/components/error-boundary.js\");\n\nvar _appRouterHeaders = __webpack_require__(/*! ./app-router-headers */ \"./node_modules/next/dist/client/components/app-router-headers.js\");\n\nfunction AppRouter(props) {\n  return /*#__PURE__*/_react[\"default\"].createElement(_errorBoundary.ErrorBoundary, {\n    errorComponent: _errorBoundary.GlobalErrorComponent\n  }, /*#__PURE__*/_react[\"default\"].createElement(Router, Object.assign({}, props)));\n}\n\n_c = AppRouter;\n\nfunction urlToUrlWithoutFlightMarker(url) {\n  var urlWithoutFlightParameters = new URL(url, location.origin); // TODO-APP: handle .rsc for static export case\n\n  return urlWithoutFlightParameters;\n}\n\nvar HotReloader =  false ? 0 : (__webpack_require__(/*! ./react-dev-overlay/hot-reloader-client */ \"./node_modules/next/dist/client/components/react-dev-overlay/hot-reloader-client.js\")[\"default\"]);\n\nfunction fetchServerResponse(url, flightRouterState, prefetch) {\n  return _fetchServerResponse.apply(this, arguments);\n}\n\nfunction _fetchServerResponse() {\n  _fetchServerResponse = _async_to_generator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url, flightRouterState, prefetch) {\n    var _headers;\n\n    var headers, res, canonicalUrl, isFlightResponse, flightData;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            headers = (_headers = {}, _defineProperty(_headers, _appRouterHeaders.RSC, '1'), _defineProperty(_headers, _appRouterHeaders.NEXT_ROUTER_STATE_TREE, JSON.stringify(flightRouterState)), _headers);\n\n            if (prefetch) {\n              // Enable prefetch response\n              headers[_appRouterHeaders.NEXT_ROUTER_PREFETCH] = '1';\n            }\n\n            _context.next = 4;\n            return fetch(url.toString(), {\n              headers: headers\n            });\n\n          case 4:\n            res = _context.sent;\n            canonicalUrl = res.redirected ? urlToUrlWithoutFlightMarker(res.url) : undefined;\n            isFlightResponse = res.headers.get('content-type') === 'application/octet-stream'; // If fetch returns something different than flight response handle it like a mpa navigation\n\n            if (isFlightResponse) {\n              _context.next = 9;\n              break;\n            }\n\n            return _context.abrupt(\"return\", [res.url, undefined]);\n\n          case 9:\n            _context.next = 11;\n            return (0, _client).createFromFetch(Promise.resolve(res));\n\n          case 11:\n            flightData = _context.sent;\n            return _context.abrupt(\"return\", [flightData, canonicalUrl]);\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _fetchServerResponse.apply(this, arguments);\n} // Ensure the initialParallelRoutes are not combined because of double-rendering in the browser with Strict Mode.\n// TODO-APP: move this back into AppRouter\n\n\nvar initialParallelRoutes =  false ? 0 : new Map();\nvar prefetched = new Set();\n\nfunction findHeadInCache(cache, parallelRoutes) {\n  var isLastItem = Object.keys(parallelRoutes).length === 0;\n\n  if (isLastItem) {\n    return cache.head;\n  }\n\n  for (var key in parallelRoutes) {\n    var _parallelRoutes$key = _slicedToArray(parallelRoutes[key], 2),\n        segment = _parallelRoutes$key[0],\n        childParallelRoutes = _parallelRoutes$key[1];\n\n    var childSegmentMap = cache.parallelRoutes.get(key);\n\n    if (!childSegmentMap) {\n      continue;\n    }\n\n    var cacheKey = Array.isArray(segment) ? segment[1] : segment;\n    var cacheNode = childSegmentMap.get(cacheKey);\n\n    if (!cacheNode) {\n      continue;\n    }\n\n    var item = findHeadInCache(cacheNode, childParallelRoutes);\n\n    if (item) {\n      return item;\n    }\n  }\n\n  return undefined;\n}\n/**\n * The global router that wraps the application components.\n */\n\n\nfunction Router(_ref) {\n  _s();\n\n  var initialHead = _ref.initialHead,\n      initialTree = _ref.initialTree,\n      initialCanonicalUrl = _ref.initialCanonicalUrl,\n      children = _ref.children,\n      assetPrefix = _ref.assetPrefix;\n  var initialState = (0, _react).useMemo(function () {\n    return {\n      tree: initialTree,\n      cache: {\n        status: _appRouterContext.CacheStates.READY,\n        data: null,\n        subTreeData: children,\n        parallelRoutes:  false ? 0 : initialParallelRoutes\n      },\n      prefetchCache: new Map(),\n      pushRef: {\n        pendingPush: false,\n        mpaNavigation: false\n      },\n      focusAndScrollRef: {\n        apply: false\n      },\n      canonicalUrl: // location.href is read as the initial value for canonicalUrl in the browser\n      // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n       true ? (0, _reducer).createHrefFromUrl(window.location) : 0\n    };\n  }, [children, initialCanonicalUrl, initialTree]);\n\n  var _useReducerWithReduxD = (0, _useReducerWithDevtools).useReducerWithReduxDevtools(_reducer.reducer, initialState),\n      _useReducerWithReduxD2 = _slicedToArray(_useReducerWithReduxD, 3),\n      _useReducerWithReduxD3 = _useReducerWithReduxD2[0],\n      tree = _useReducerWithReduxD3.tree,\n      cache = _useReducerWithReduxD3.cache,\n      prefetchCache = _useReducerWithReduxD3.prefetchCache,\n      pushRef = _useReducerWithReduxD3.pushRef,\n      focusAndScrollRef = _useReducerWithReduxD3.focusAndScrollRef,\n      canonicalUrl = _useReducerWithReduxD3.canonicalUrl,\n      dispatch = _useReducerWithReduxD2[1],\n      sync = _useReducerWithReduxD2[2];\n\n  var head = (0, _react).useMemo(function () {\n    return findHeadInCache(cache, tree[1]);\n  }, [cache, tree]);\n  (0, _react).useEffect(function () {\n    // Ensure initialParallelRoutes is cleaned up from memory once it's used.\n    initialParallelRoutes = null;\n  }, []); // Add memoized pathname/query for useSearchParams and usePathname.\n\n  var _useMemo = (0, _react).useMemo(function () {\n    var url = new URL(canonicalUrl,  false ? 0 : window.location.href);\n    return {\n      // This is turned into a readonly class in `useSearchParams`\n      searchParams: url.searchParams,\n      pathname: url.pathname\n    };\n  }, [canonicalUrl]),\n      searchParams = _useMemo.searchParams,\n      pathname = _useMemo.pathname;\n  /**\n  * Server response that only patches the cache and tree.\n  */\n\n\n  var changeByServerResponse = (0, _react).useCallback(function (previousTree, flightData, overrideCanonicalUrl) {\n    dispatch({\n      type: _reducer.ACTION_SERVER_PATCH,\n      flightData: flightData,\n      previousTree: previousTree,\n      overrideCanonicalUrl: overrideCanonicalUrl,\n      cache: {\n        status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n        data: null,\n        subTreeData: null,\n        parallelRoutes: new Map()\n      },\n      mutable: {}\n    });\n  }, [dispatch]);\n  /**\n  * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.\n  */\n\n  var appRouter = (0, _react).useMemo(function () {\n    var navigate = function navigate(href, navigateType, forceOptimisticNavigation) {\n      return dispatch({\n        type: _reducer.ACTION_NAVIGATE,\n        url: new URL(href, location.origin),\n        forceOptimisticNavigation: forceOptimisticNavigation,\n        navigateType: navigateType,\n        cache: {\n          status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n          data: null,\n          subTreeData: null,\n          parallelRoutes: new Map()\n        },\n        mutable: {}\n      });\n    };\n\n    var routerInstance = {\n      back: function back() {\n        return window.history.back();\n      },\n      forward: function forward() {\n        return window.history.forward();\n      },\n      // TODO-APP: implement prefetching of flight\n      prefetch: _async_to_generator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(href) {\n        var url, ref, routerTree, serverResponse;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!prefetched.has(href)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                prefetched.add(href);\n                url = new URL(href, location.origin);\n                _context2.prev = 4;\n                routerTree = ((ref = window.history.state) == null ? void 0 : ref.tree) || initialTree; // TODO-APP: handle case where history.state is not the new router history entry\n\n                _context2.next = 8;\n                return fetchServerResponse(url, // initialTree is used when history.state.tree is missing because the history state is set in `useEffect` below, it being missing means this is the hydration case.\n                routerTree, true);\n\n              case 8:\n                serverResponse = _context2.sent;\n\n                // @ts-ignore startTransition exists\n                _react[\"default\"].startTransition(function () {\n                  dispatch({\n                    type: _reducer.ACTION_PREFETCH,\n                    url: url,\n                    tree: routerTree,\n                    serverResponse: serverResponse\n                  });\n                });\n\n                _context2.next = 15;\n                break;\n\n              case 12:\n                _context2.prev = 12;\n                _context2.t0 = _context2[\"catch\"](4);\n                console.error('PREFETCH ERROR', _context2.t0);\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[4, 12]]);\n      })),\n      replace: function replace(href) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        // @ts-ignore startTransition exists\n        _react[\"default\"].startTransition(function () {\n          navigate(href, 'replace', Boolean(options.forceOptimisticNavigation));\n        });\n      },\n      push: function push(href) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        // @ts-ignore startTransition exists\n        _react[\"default\"].startTransition(function () {\n          navigate(href, 'push', Boolean(options.forceOptimisticNavigation));\n        });\n      },\n      refresh: function refresh() {\n        // @ts-ignore startTransition exists\n        _react[\"default\"].startTransition(function () {\n          dispatch({\n            type: _reducer.ACTION_REFRESH,\n            // TODO-APP: revisit if this needs to be passed.\n            cache: {\n              status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n              data: null,\n              subTreeData: null,\n              parallelRoutes: new Map()\n            },\n            mutable: {}\n          });\n        });\n      }\n    };\n    return routerInstance;\n  }, [dispatch, initialTree]);\n  (0, _react).useEffect(function () {\n    // When mpaNavigation flag is set do a hard navigation to the new url.\n    if (pushRef.mpaNavigation) {\n      window.location.href = canonicalUrl;\n      return;\n    } // Identifier is shortened intentionally.\n    // __NA is used to identify if the history entry can be handled by the app-router.\n    // __N is used to identify if the history entry can be handled by the old router.\n\n\n    var historyState = {\n      __NA: true,\n      tree: tree\n    };\n\n    if (pushRef.pendingPush && (0, _reducer).createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl) {\n      // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n      pushRef.pendingPush = false;\n      window.history.pushState(historyState, '', canonicalUrl);\n    } else {\n      window.history.replaceState(historyState, '', canonicalUrl);\n    }\n\n    sync();\n  }, [tree, pushRef, canonicalUrl, sync]); // Add `window.nd` for debugging purposes.\n  // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n\n  if (true) {\n    // @ts-ignore this is for debugging\n    window.nd = {\n      router: appRouter,\n      cache: cache,\n      prefetchCache: prefetchCache,\n      tree: tree\n    };\n  }\n  /**\n  * Handle popstate event, this is used to handle back/forward in the browser.\n  * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n  * That case can happen when the old router injected the history entry.\n  */\n\n\n  var onPopState = (0, _react).useCallback(function (_ref2) {\n    var state = _ref2.state;\n\n    if (!state) {\n      // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n      return;\n    } // TODO-APP: this case happens when pushState/replaceState was called outside of Next.js or when the history entry was pushed by the old router.\n    // It reloads the page in this case but we might have to revisit this as the old router ignores it.\n\n\n    if (!state.__NA) {\n      window.location.reload();\n      return;\n    } // @ts-ignore useTransition exists\n    // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n    // Without startTransition works if the cache is there for this path\n\n\n    _react[\"default\"].startTransition(function () {\n      dispatch({\n        type: _reducer.ACTION_RESTORE,\n        url: new URL(window.location.href),\n        tree: state.tree\n      });\n    });\n  }, [dispatch]); // Register popstate event to call onPopstate.\n\n  (0, _react).useEffect(function () {\n    window.addEventListener('popstate', onPopState);\n    return function () {\n      window.removeEventListener('popstate', onPopState);\n    };\n  }, [onPopState]);\n\n  var content = /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, head || initialHead, cache.subTreeData);\n\n  return /*#__PURE__*/_react[\"default\"].createElement(_hooksClientContext.PathnameContext.Provider, {\n    value: pathname\n  }, /*#__PURE__*/_react[\"default\"].createElement(_hooksClientContext.SearchParamsContext.Provider, {\n    value: searchParams\n  }, /*#__PURE__*/_react[\"default\"].createElement(_appRouterContext.GlobalLayoutRouterContext.Provider, {\n    value: {\n      changeByServerResponse: changeByServerResponse,\n      tree: tree,\n      focusAndScrollRef: focusAndScrollRef\n    }\n  }, /*#__PURE__*/_react[\"default\"].createElement(_appRouterContext.AppRouterContext.Provider, {\n    value: appRouter\n  }, /*#__PURE__*/_react[\"default\"].createElement(_appRouterContext.LayoutRouterContext.Provider, {\n    value: {\n      childNodes: cache.parallelRoutes,\n      tree: tree,\n      // Root node always has `url`\n      // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n      url: canonicalUrl\n    }\n  }, HotReloader ? /*#__PURE__*/_react[\"default\"].createElement(HotReloader, {\n    assetPrefix: assetPrefix\n  }, content) : content)))));\n}\n\n_s(Router, \"E4Qd1Kk83CxC+YgSLfkcNAcoSWY=\", true);\n\n_c2 = Router;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"AppRouter\");\n$RefreshReg$(_c2, \"Router\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7OztBQUNBQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxrQkFBQSxHQUFrQkUsU0FBbEI7QUFDQUYsMkJBQUEsR0FBOEJHLG1CQUE5Qjs7QUFDQSxJQUFJQyxtQkFBbUIsR0FBR0MseUlBQTFCOztBQUNBLElBQUlDLHlCQUF5QixHQUFHRCxxSkFBaEM7O0FBQ0EsSUFBSUUsTUFBTSxHQUFHRCx5QkFBeUIsQ0FBQ0QsbUJBQU8sQ0FBQywrREFBRCxDQUFSLENBQXRDOztBQUNBLElBQUlHLE9BQU8sR0FBR0gsbUJBQU8sQ0FBQyxnSUFBRCxDQUFyQjs7QUFDQSxJQUFJSSxpQkFBaUIsR0FBR0osbUJBQU8sQ0FBQyxzR0FBRCxDQUEvQjs7QUFDQSxJQUFJSyxRQUFRLEdBQUdMLG1CQUFPLENBQUMsd0VBQUQsQ0FBdEI7O0FBQ0EsSUFBSU0sbUJBQW1CLEdBQUdOLG1CQUFPLENBQUMsMEdBQUQsQ0FBakM7O0FBQ0EsSUFBSU8sdUJBQXVCLEdBQUdQLG1CQUFPLENBQUMsNEdBQUQsQ0FBckM7O0FBQ0EsSUFBSVEsY0FBYyxHQUFHUixtQkFBTyxDQUFDLHNGQUFELENBQTVCOztBQUNBLElBQUlTLGlCQUFpQixHQUFHVCxtQkFBTyxDQUFDLDhGQUFELENBQS9COztBQUNBLFNBQVNILFNBQVQsQ0FBbUJhLEtBQW5CLEVBQTBCO0VBQ3RCLE9BQU8sYUFBY1IsTUFBTSxXQUFOLENBQWVTLGFBQWYsQ0FBNkJILGNBQWMsQ0FBQ0ksYUFBNUMsRUFBMkQ7SUFDNUVDLGNBQWMsRUFBRUwsY0FBYyxDQUFDTTtFQUQ2QyxDQUEzRCxFQUVsQixhQUFjWixNQUFNLFdBQU4sQ0FBZVMsYUFBZixDQUE2QkksTUFBN0IsRUFBcUN0QixNQUFNLENBQUN1QixNQUFQLENBQWMsRUFBZCxFQUFrQk4sS0FB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QTZCUCxpQkFBaUIsQ0FBQzZJLGdCQUFsQixDQUFtQ0gsUUFBaEUsRUFBMEU7SUFDdkZsSixLQUFLLEVBQUUyRztFQURnRixDQUExRSxFQUVkLGFBQWNyRyxNQUFNLFdBQU4sQ0FBZVMsYUFBZixDQUE2QlAsaUJBQWlCLENBQUM4SSxtQkFBbEIsQ0FBc0NKLFFBQW5FLEVBQTZFO0lBQzFGbEosS0FBSyxFQUFFO01BQ0h1SixVQUFVLEVBQUUvRixLQUFLLENBQUNDLGNBRGY7TUFFSHFCLElBQUksRUFBRUEsSUFGSDtNQUdIO01BQ0E7TUFDQXhELEdBQUcsRUFBRW9CO0lBTEY7RUFEbUYsQ0FBN0UsRUFRZGYsV0FBVyxHQUFHLGFBQWNyQixNQUFNLFdBQU4sQ0FBZVMsYUFBZixDQUE2QlksV0FBN0IsRUFBMEM7SUFDckVnRCxXQUFXLEVBQUVBO0VBRHdELENBQTFDLEVBRTVCb0UsT0FGNEIsQ0FBakIsR0FFQUEsT0FWRyxDQUZBLENBTkEsQ0FGQSxDQUZJLENBQXJCO0FBdUJIOztHQXpQWTVILE07O01BQUFBLE07O0FBMlBiLElBQUksQ0FBQyxPQUFPcEIsT0FBTyxXQUFkLEtBQTJCLFVBQTNCLElBQTBDLE9BQU9BLE9BQU8sV0FBZCxLQUEyQixRQUEzQixJQUF1Q0EsT0FBTyxXQUFQLEtBQW9CLElBQXRHLEtBQWdILE9BQU9BLE9BQU8sV0FBUCxDQUFnQnlKLFVBQXZCLEtBQXNDLFdBQTFKLEVBQXVLO0VBQ3JLM0osTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUFPLFdBQTdCLEVBQXVDLFlBQXZDLEVBQXFEO0lBQUVDLEtBQUssRUFBRTtFQUFULENBQXJEO0VBQ0FILE1BQU0sQ0FBQ3VCLE1BQVAsQ0FBY3JCLE9BQU8sV0FBckIsRUFBK0JBLE9BQS9CO0VBQ0EwSixNQUFNLENBQUMxSixPQUFQLEdBQWlCQSxPQUFPLFdBQXhCO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLmpzPzQxNTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFwcFJvdXRlcjtcbmV4cG9ydHMuZmV0Y2hTZXJ2ZXJSZXNwb25zZSA9IGZldGNoU2VydmVyUmVzcG9uc2U7XG52YXIgX2FzeW5jX3RvX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19hc3luY190b19nZW5lcmF0b3IuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2xpZW50ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50XCIpO1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xudmFyIF9yZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlclwiKTtcbnZhciBfaG9va3NDbGllbnRDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHRcIik7XG52YXIgX3VzZVJlZHVjZXJXaXRoRGV2dG9vbHMgPSByZXF1aXJlKFwiLi91c2UtcmVkdWNlci13aXRoLWRldnRvb2xzXCIpO1xudmFyIF9lcnJvckJvdW5kYXJ5ID0gcmVxdWlyZShcIi4vZXJyb3ItYm91bmRhcnlcIik7XG52YXIgX2FwcFJvdXRlckhlYWRlcnMgPSByZXF1aXJlKFwiLi9hcHAtcm91dGVyLWhlYWRlcnNcIik7XG5mdW5jdGlvbiBBcHBSb3V0ZXIocHJvcHMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9lcnJvckJvdW5kYXJ5LkVycm9yQm91bmRhcnksIHtcbiAgICAgICAgZXJyb3JDb21wb25lbnQ6IF9lcnJvckJvdW5kYXJ5Lkdsb2JhbEVycm9yQ29tcG9uZW50XG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKSk7XG59XG5cbmZ1bmN0aW9uIHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcih1cmwpIHtcbiAgICBjb25zdCB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5vcmlnaW4pO1xuICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgLnJzYyBmb3Igc3RhdGljIGV4cG9ydCBjYXNlXG4gICAgcmV0dXJuIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzO1xufVxuY29uc3QgSG90UmVsb2FkZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gbnVsbCA6IHJlcXVpcmUoJy4vcmVhY3QtZGV2LW92ZXJsYXkvaG90LXJlbG9hZGVyLWNsaWVudCcpLmRlZmF1bHQ7XG5mdW5jdGlvbiBmZXRjaFNlcnZlclJlc3BvbnNlKHVybCwgZmxpZ2h0Um91dGVyU3RhdGUsIHByZWZldGNoKSB7XG4gICAgcmV0dXJuIF9mZXRjaFNlcnZlclJlc3BvbnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfZmV0Y2hTZXJ2ZXJSZXNwb25zZSgpIHtcbiAgICBfZmV0Y2hTZXJ2ZXJSZXNwb25zZSA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKHVybCwgZmxpZ2h0Um91dGVyU3RhdGUsIHByZWZldGNoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAvLyBFbmFibGUgZmxpZ2h0IHJlc3BvbnNlXG4gICAgICAgICAgICBbX2FwcFJvdXRlckhlYWRlcnMuUlNDXTogJzEnLFxuICAgICAgICAgICAgLy8gUHJvdmlkZSB0aGUgY3VycmVudCByb3V0ZXIgc3RhdGVcbiAgICAgICAgICAgIFtfYXBwUm91dGVySGVhZGVycy5ORVhUX1JPVVRFUl9TVEFURV9UUkVFXTogSlNPTi5zdHJpbmdpZnkoZmxpZ2h0Um91dGVyU3RhdGUpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcmVmZXRjaCkge1xuICAgICAgICAgICAgLy8gRW5hYmxlIHByZWZldGNoIHJlc3BvbnNlXG4gICAgICAgICAgICBoZWFkZXJzW19hcHBSb3V0ZXJIZWFkZXJzLk5FWFRfUk9VVEVSX1BSRUZFVENIXSA9ICcxJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSB5aWVsZCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsID0gcmVzLnJlZGlyZWN0ZWQgPyB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIocmVzLnVybCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGlzRmxpZ2h0UmVzcG9uc2UgPSByZXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgLy8gSWYgZmV0Y2ggcmV0dXJucyBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gZmxpZ2h0IHJlc3BvbnNlIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICAgICAgaWYgKCFpc0ZsaWdodFJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHJlcy51cmwsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgYGZldGNoYCByZWFkYWJsZSBzdHJlYW0gdGhhdCBjYW4gYmUgdW53cmFwcGVkIGJ5IGBSZWFjdC51c2VgLlxuICAgICAgICBjb25zdCBmbGlnaHREYXRhID0geWllbGQgKDAsIF9jbGllbnQpLmNyZWF0ZUZyb21GZXRjaChQcm9taXNlLnJlc29sdmUocmVzKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmbGlnaHREYXRhLFxuICAgICAgICAgICAgY2Fub25pY2FsVXJsXG4gICAgICAgIF07XG4gICAgfSk7XG4gICAgcmV0dXJuIF9mZXRjaFNlcnZlclJlc3BvbnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyBFbnN1cmUgdGhlIGluaXRpYWxQYXJhbGxlbFJvdXRlcyBhcmUgbm90IGNvbWJpbmVkIGJlY2F1c2Ugb2YgZG91YmxlLXJlbmRlcmluZyBpbiB0aGUgYnJvd3NlciB3aXRoIFN0cmljdCBNb2RlLlxuLy8gVE9ETy1BUFA6IG1vdmUgdGhpcyBiYWNrIGludG8gQXBwUm91dGVyXG5sZXQgaW5pdGlhbFBhcmFsbGVsUm91dGVzID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogbmV3IE1hcCgpO1xuY29uc3QgcHJlZmV0Y2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGZpbmRIZWFkSW5DYWNoZShjYWNoZSwgcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBjb25zdCBpc0xhc3RJdGVtID0gT2JqZWN0LmtleXMocGFyYWxsZWxSb3V0ZXMpLmxlbmd0aCA9PT0gMDtcbiAgICBpZiAoaXNMYXN0SXRlbSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuaGVhZDtcbiAgICB9XG4gICAgZm9yKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcyl7XG4gICAgICAgIGNvbnN0IFtzZWdtZW50LCBjaGlsZFBhcmFsbGVsUm91dGVzXSA9IHBhcmFsbGVsUm91dGVzW2tleV07XG4gICAgICAgIGNvbnN0IGNoaWxkU2VnbWVudE1hcCA9IGNhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpO1xuICAgICAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnQ7XG4gICAgICAgIGNvbnN0IGNhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAoIWNhY2hlTm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IGZpbmRIZWFkSW5DYWNoZShjYWNoZU5vZGUsIGNoaWxkUGFyYWxsZWxSb3V0ZXMpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogVGhlIGdsb2JhbCByb3V0ZXIgdGhhdCB3cmFwcyB0aGUgYXBwbGljYXRpb24gY29tcG9uZW50cy5cbiAqLyBmdW5jdGlvbiBSb3V0ZXIoeyBpbml0aWFsSGVhZCAsIGluaXRpYWxUcmVlICwgaW5pdGlhbENhbm9uaWNhbFVybCAsIGNoaWxkcmVuICwgYXNzZXRQcmVmaXggIH0pIHtcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT57XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmVlOiBpbml0aWFsVHJlZSxcbiAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWSxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBuZXcgTWFwKCkgOiBpbml0aWFsUGFyYWxsZWxSb3V0ZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5vbmljYWxVcmw6IC8vIGxvY2F0aW9uLmhyZWYgaXMgcmVhZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgY2Fub25pY2FsVXJsIGluIHRoZSBicm93c2VyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHNhZmUgdG8gZG8gYXMgY2Fub25pY2FsVXJsIGNhbid0IGJlIHJlbmRlcmVkLCBpdCdzIG9ubHkgdXNlZCB0byBjb250cm9sIHRoZSBoaXN0b3J5IHVwZGF0ZXMgaW4gdGhlIHVzZUVmZmVjdCBmdXJ0aGVyIGRvd24gaW4gdGhpcyBmaWxlLlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoMCwgX3JlZHVjZXIpLmNyZWF0ZUhyZWZGcm9tVXJsKHdpbmRvdy5sb2NhdGlvbikgOiBpbml0aWFsQ2Fub25pY2FsVXJsXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaW5pdGlhbENhbm9uaWNhbFVybCxcbiAgICAgICAgaW5pdGlhbFRyZWVcbiAgICBdKTtcbiAgICBjb25zdCBbeyB0cmVlICwgY2FjaGUgLCBwcmVmZXRjaENhY2hlICwgcHVzaFJlZiAsIGZvY3VzQW5kU2Nyb2xsUmVmICwgY2Fub25pY2FsVXJsICB9LCBkaXNwYXRjaCwgc3luYywgXSA9ICgwLCBfdXNlUmVkdWNlcldpdGhEZXZ0b29scykudXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzKF9yZWR1Y2VyLnJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3QgaGVhZCA9ICgwLCBfcmVhY3QpLnVzZU1lbW8oKCk9PntcbiAgICAgICAgcmV0dXJuIGZpbmRIZWFkSW5DYWNoZShjYWNoZSwgdHJlZVsxXSk7XG4gICAgfSwgW1xuICAgICAgICBjYWNoZSxcbiAgICAgICAgdHJlZVxuICAgIF0pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBFbnN1cmUgaW5pdGlhbFBhcmFsbGVsUm91dGVzIGlzIGNsZWFuZWQgdXAgZnJvbSBtZW1vcnkgb25jZSBpdCdzIHVzZWQuXG4gICAgICAgIGluaXRpYWxQYXJhbGxlbFJvdXRlcyA9IG51bGw7XG4gICAgfSwgW10pO1xuICAgIC8vIEFkZCBtZW1vaXplZCBwYXRobmFtZS9xdWVyeSBmb3IgdXNlU2VhcmNoUGFyYW1zIGFuZCB1c2VQYXRobmFtZS5cbiAgICBjb25zdCB7IHNlYXJjaFBhcmFtcyAsIHBhdGhuYW1lICB9ID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGNhbm9uaWNhbFVybCwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0dXJuZWQgaW50byBhIHJlYWRvbmx5IGNsYXNzIGluIGB1c2VTZWFyY2hQYXJhbXNgXG4gICAgICAgICAgICBzZWFyY2hQYXJhbXM6IHVybC5zZWFyY2hQYXJhbXMsXG4gICAgICAgICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjYW5vbmljYWxVcmxcbiAgICBdKTtcbiAgICAvKipcbiAgICogU2VydmVyIHJlc3BvbnNlIHRoYXQgb25seSBwYXRjaGVzIHRoZSBjYWNoZSBhbmQgdHJlZS5cbiAgICovIGNvbnN0IGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygocHJldmlvdXNUcmVlLCBmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybCk9PntcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogX3JlZHVjZXIuQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgICBwcmV2aW91c1RyZWUsXG4gICAgICAgICAgICBvdmVycmlkZUNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11dGFibGU6IHt9XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgZGlzcGF0Y2hcbiAgICBdKTtcbiAgICAvKipcbiAgICogVGhlIGFwcCByb3V0ZXIgdGhhdCBpcyBleHBvc2VkIHRocm91Z2ggYHVzZVJvdXRlcmAuIEl0J3Mgb25seSBjb25jZXJuZWQgd2l0aCBkaXNwYXRjaGluZyBhY3Rpb25zIHRvIHRoZSByZWR1Y2VyLCBkb2VzIG5vdCBob2xkIHN0YXRlLlxuICAgKi8gY29uc3QgYXBwUm91dGVyID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBuYXZpZ2F0ZSA9IChocmVmLCBuYXZpZ2F0ZVR5cGUsIGZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24pPT57XG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IF9yZWR1Y2VyLkFDVElPTl9OQVZJR0FURSxcbiAgICAgICAgICAgICAgICB1cmw6IG5ldyBVUkwoaHJlZiwgbG9jYXRpb24ub3JpZ2luKSxcbiAgICAgICAgICAgICAgICBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICAgIG5hdmlnYXRlVHlwZSxcbiAgICAgICAgICAgICAgICBjYWNoZToge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtdXRhYmxlOiB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvdXRlckluc3RhbmNlID0ge1xuICAgICAgICAgICAgYmFjazogKCk9PndpbmRvdy5oaXN0b3J5LmJhY2soKSxcbiAgICAgICAgICAgIGZvcndhcmQ6ICgpPT53aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCksXG4gICAgICAgICAgICAvLyBUT0RPLUFQUDogaW1wbGVtZW50IHByZWZldGNoaW5nIG9mIGZsaWdodFxuICAgICAgICAgICAgcHJlZmV0Y2g6IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKGhyZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwcmVmZXRjaCBoYXMgYWxyZWFkeSBiZWVuIHRyaWdnZXJlZCwgZG9uJ3QgdHJpZ2dlciBpdCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBpZiAocHJlZmV0Y2hlZC5oYXMoaHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmVmZXRjaGVkLmFkZChocmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGhyZWYsIGxvY2F0aW9uLm9yaWdpbik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm91dGVyVHJlZSA9ICgocmVmID0gd2luZG93Lmhpc3Rvcnkuc3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiByZWYudHJlZSkgfHwgaW5pdGlhbFRyZWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgY2FzZSB3aGVyZSBoaXN0b3J5LnN0YXRlIGlzIG5vdCB0aGUgbmV3IHJvdXRlciBoaXN0b3J5IGVudHJ5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlclJlc3BvbnNlID0geWllbGQgZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIC8vIGluaXRpYWxUcmVlIGlzIHVzZWQgd2hlbiBoaXN0b3J5LnN0YXRlLnRyZWUgaXMgbWlzc2luZyBiZWNhdXNlIHRoZSBoaXN0b3J5IHN0YXRlIGlzIHNldCBpbiBgdXNlRWZmZWN0YCBiZWxvdywgaXQgYmVpbmcgbWlzc2luZyBtZWFucyB0aGlzIGlzIHRoZSBoeWRyYXRpb24gY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgcm91dGVyVHJlZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc3RhcnRUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfcmVkdWNlci5BQ1RJT05fUFJFRkVUQ0gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHJvdXRlclRyZWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUFJFRkVUQ0ggRVJST1InLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVwbGFjZTogKGhyZWYsIG9wdGlvbnMgPSB7fSk9PntcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGUoaHJlZiwgJ3JlcGxhY2UnLCBCb29sZWFuKG9wdGlvbnMuZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHB1c2g6IChocmVmLCBvcHRpb25zID0ge30pPT57XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlKGhyZWYsICdwdXNoJywgQm9vbGVhbihvcHRpb25zLmZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZyZXNoOiAoKT0+e1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc3RhcnRUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfcmVkdWNlci5BQ1RJT05fUkVGUkVTSCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiByZXZpc2l0IGlmIHRoaXMgbmVlZHMgdG8gYmUgcGFzc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZToge31cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3V0ZXJJbnN0YW5jZTtcbiAgICB9LCBbXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBpbml0aWFsVHJlZVxuICAgIF0pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBXaGVuIG1wYU5hdmlnYXRpb24gZmxhZyBpcyBzZXQgZG8gYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIG5ldyB1cmwuXG4gICAgICAgIGlmIChwdXNoUmVmLm1wYU5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gY2Fub25pY2FsVXJsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElkZW50aWZpZXIgaXMgc2hvcnRlbmVkIGludGVudGlvbmFsbHkuXG4gICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgICAgLy8gX19OIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIG9sZCByb3V0ZXIuXG4gICAgICAgIGNvbnN0IGhpc3RvcnlTdGF0ZSA9IHtcbiAgICAgICAgICAgIF9fTkE6IHRydWUsXG4gICAgICAgICAgICB0cmVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwdXNoUmVmLnBlbmRpbmdQdXNoICYmICgwLCBfcmVkdWNlcikuY3JlYXRlSHJlZkZyb21VcmwobmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikpICE9PSBjYW5vbmljYWxVcmwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaW50ZW50aW9uYWxseSBtdXRhdGVzIFJlYWN0IHN0YXRlLCBwdXNoUmVmIGlzIG92ZXJ3cml0dGVuIHRvIGVuc3VyZSBhZGRpdGlvbmFsIHB1c2gvcmVwbGFjZSBjYWxscyBkbyBub3QgdHJpZ2dlciBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkuXG4gICAgICAgICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoID0gZmFsc2U7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpO1xuICAgICAgICB9XG4gICAgICAgIHN5bmMoKTtcbiAgICB9LCBbXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHB1c2hSZWYsXG4gICAgICAgIGNhbm9uaWNhbFVybCxcbiAgICAgICAgc3luY1xuICAgIF0pO1xuICAgIC8vIEFkZCBgd2luZG93Lm5kYCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgIC8vIFRoaXMgaXMgbm90IG1lYW50IGZvciB1c2UgaW4gYXBwbGljYXRpb25zIGFzIGNvbmN1cnJlbnQgcmVuZGVyaW5nIHdpbGwgYWZmZWN0IHRoZSBjYWNoZS90cmVlL3JvdXRlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgd2luZG93Lm5kID0ge1xuICAgICAgICAgICAgcm91dGVyOiBhcHBSb3V0ZXIsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICB0cmVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgKiBIYW5kbGUgcG9wc3RhdGUgZXZlbnQsIHRoaXMgaXMgdXNlZCB0byBoYW5kbGUgYmFjay9mb3J3YXJkIGluIHRoZSBicm93c2VyLlxuICAgKiBCeSBkZWZhdWx0IGRpc3BhdGNoZXMgQUNUSU9OX1JFU1RPUkUsIGhvd2V2ZXIgaWYgdGhlIGhpc3RvcnkgZW50cnkgd2FzIG5vdCBwdXNoZWQvcmVwbGFjZWQgYnkgYXBwLXJvdXRlciBpdCB3aWxsIHJlbG9hZCB0aGUgcGFnZS5cbiAgICogVGhhdCBjYXNlIGNhbiBoYXBwZW4gd2hlbiB0aGUgb2xkIHJvdXRlciBpbmplY3RlZCB0aGUgaGlzdG9yeSBlbnRyeS5cbiAgICovIGNvbnN0IG9uUG9wU3RhdGUgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoeyBzdGF0ZSAgfSk9PntcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHRoaXMgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIHdhcyBjYWxsZWQgb3V0c2lkZSBvZiBOZXh0LmpzLiBJdCBzaG91bGQgcHJvYmFibHkgcmVsb2FkIHRoZSBwYWdlIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPLUFQUDogdGhpcyBjYXNlIGhhcHBlbnMgd2hlbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIHdhcyBjYWxsZWQgb3V0c2lkZSBvZiBOZXh0LmpzIG9yIHdoZW4gdGhlIGhpc3RvcnkgZW50cnkgd2FzIHB1c2hlZCBieSB0aGUgb2xkIHJvdXRlci5cbiAgICAgICAgLy8gSXQgcmVsb2FkcyB0aGUgcGFnZSBpbiB0aGlzIGNhc2UgYnV0IHdlIG1pZ2h0IGhhdmUgdG8gcmV2aXNpdCB0aGlzIGFzIHRoZSBvbGQgcm91dGVyIGlnbm9yZXMgaXQuXG4gICAgICAgIGlmICghc3RhdGUuX19OQSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgdXNlVHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgLy8gVE9ETy1BUFA6IElkZWFsbHkgdGhlIGJhY2sgYnV0dG9uIHNob3VsZCBub3QgdXNlIHN0YXJ0VHJhbnNpdGlvbiBhcyBpdCBzaG91bGQgYXBwbHkgdGhlIHVwZGF0ZXMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBXaXRob3V0IHN0YXJ0VHJhbnNpdGlvbiB3b3JrcyBpZiB0aGUgY2FjaGUgaXMgdGhlcmUgZm9yIHRoaXMgcGF0aFxuICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBfcmVkdWNlci5BQ1RJT05fUkVTVE9SRSxcbiAgICAgICAgICAgICAgICB1cmw6IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpLFxuICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGRpc3BhdGNoXG4gICAgXSk7XG4gICAgLy8gUmVnaXN0ZXIgcG9wc3RhdGUgZXZlbnQgdG8gY2FsbCBvblBvcHN0YXRlLlxuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG9uUG9wU3RhdGVcbiAgICBdKTtcbiAgICBjb25zdCBjb250ZW50ID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBoZWFkIHx8IGluaXRpYWxIZWFkLCBjYWNoZS5zdWJUcmVlRGF0YSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaG9va3NDbGllbnRDb250ZXh0LlBhdGhuYW1lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcGF0aG5hbWVcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hvb2tzQ2xpZW50Q29udGV4dC5TZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBzZWFyY2hQYXJhbXNcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcFJvdXRlckNvbnRleHQuR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSxcbiAgICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZlxuICAgICAgICB9XG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LkFwcFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGFwcFJvdXRlclxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5MYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBjaGlsZE5vZGVzOiBjYWNoZS5wYXJhbGxlbFJvdXRlcyxcbiAgICAgICAgICAgIHRyZWU6IHRyZWUsXG4gICAgICAgICAgICAvLyBSb290IG5vZGUgYWx3YXlzIGhhcyBgdXJsYFxuICAgICAgICAgICAgLy8gUHJvdmlkZWQgaW4gQXBwVHJlZUNvbnRleHQgdG8gZW5zdXJlIGl0IGNhbiBiZSBvdmVyd3JpdHRlbiBpbiBsYXlvdXQtcm91dGVyXG4gICAgICAgICAgICB1cmw6IGNhbm9uaWNhbFVybFxuICAgICAgICB9XG4gICAgfSwgSG90UmVsb2FkZXIgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSG90UmVsb2FkZXIsIHtcbiAgICAgICAgYXNzZXRQcmVmaXg6IGFzc2V0UHJlZml4XG4gICAgfSwgY29udGVudCkgOiBjb250ZW50KSkpKSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXBwUm91dGVyIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIl9hc3luY190b19nZW5lcmF0b3IiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZWFjdCIsIl9jbGllbnQiLCJfYXBwUm91dGVyQ29udGV4dCIsIl9yZWR1Y2VyIiwiX2hvb2tzQ2xpZW50Q29udGV4dCIsIl91c2VSZWR1Y2VyV2l0aERldnRvb2xzIiwiX2Vycm9yQm91bmRhcnkiLCJfYXBwUm91dGVySGVhZGVycyIsInByb3BzIiwiY3JlYXRlRWxlbWVudCIsIkVycm9yQm91bmRhcnkiLCJlcnJvckNvbXBvbmVudCIsIkdsb2JhbEVycm9yQ29tcG9uZW50IiwiUm91dGVyIiwiYXNzaWduIiwidXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyIiwidXJsIiwidXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsIkhvdFJlbG9hZGVyIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJwcmVmZXRjaCIsIl9mZXRjaFNlcnZlclJlc3BvbnNlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJoZWFkZXJzIiwiUlNDIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRSIsIkpTT04iLCJzdHJpbmdpZnkiLCJORVhUX1JPVVRFUl9QUkVGRVRDSCIsImZldGNoIiwidG9TdHJpbmciLCJyZXMiLCJjYW5vbmljYWxVcmwiLCJyZWRpcmVjdGVkIiwidW5kZWZpbmVkIiwiaXNGbGlnaHRSZXNwb25zZSIsImdldCIsImNyZWF0ZUZyb21GZXRjaCIsIlByb21pc2UiLCJyZXNvbHZlIiwiZmxpZ2h0RGF0YSIsImluaXRpYWxQYXJhbGxlbFJvdXRlcyIsIk1hcCIsInByZWZldGNoZWQiLCJTZXQiLCJmaW5kSGVhZEluQ2FjaGUiLCJjYWNoZSIsInBhcmFsbGVsUm91dGVzIiwiaXNMYXN0SXRlbSIsImtleXMiLCJsZW5ndGgiLCJoZWFkIiwia2V5Iiwic2VnbWVudCIsImNoaWxkUGFyYWxsZWxSb3V0ZXMiLCJjaGlsZFNlZ21lbnRNYXAiLCJjYWNoZUtleSIsIkFycmF5IiwiaXNBcnJheSIsImNhY2hlTm9kZSIsIml0ZW0iLCJpbml0aWFsSGVhZCIsImluaXRpYWxUcmVlIiwiaW5pdGlhbENhbm9uaWNhbFVybCIsImNoaWxkcmVuIiwiYXNzZXRQcmVmaXgiLCJpbml0aWFsU3RhdGUiLCJ1c2VNZW1vIiwidHJlZSIsInN0YXR1cyIsIkNhY2hlU3RhdGVzIiwiUkVBRFkiLCJkYXRhIiwic3ViVHJlZURhdGEiLCJwcmVmZXRjaENhY2hlIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsImZvY3VzQW5kU2Nyb2xsUmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ3aW5kb3ciLCJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMiLCJyZWR1Y2VyIiwiZGlzcGF0Y2giLCJzeW5jIiwidXNlRWZmZWN0IiwiaHJlZiIsInNlYXJjaFBhcmFtcyIsInBhdGhuYW1lIiwiY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSIsInVzZUNhbGxiYWNrIiwicHJldmlvdXNUcmVlIiwib3ZlcnJpZGVDYW5vbmljYWxVcmwiLCJ0eXBlIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsIkxBWllfSU5JVElBTElaRUQiLCJtdXRhYmxlIiwiYXBwUm91dGVyIiwibmF2aWdhdGUiLCJuYXZpZ2F0ZVR5cGUiLCJmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uIiwiQUNUSU9OX05BVklHQVRFIiwicm91dGVySW5zdGFuY2UiLCJiYWNrIiwiaGlzdG9yeSIsImZvcndhcmQiLCJoYXMiLCJhZGQiLCJyb3V0ZXJUcmVlIiwicmVmIiwic3RhdGUiLCJzZXJ2ZXJSZXNwb25zZSIsInN0YXJ0VHJhbnNpdGlvbiIsIkFDVElPTl9QUkVGRVRDSCIsImNvbnNvbGUiLCJlcnJvciIsInJlcGxhY2UiLCJvcHRpb25zIiwiQm9vbGVhbiIsInB1c2giLCJyZWZyZXNoIiwiQUNUSU9OX1JFRlJFU0giLCJoaXN0b3J5U3RhdGUiLCJfX05BIiwicHVzaFN0YXRlIiwicmVwbGFjZVN0YXRlIiwibmQiLCJyb3V0ZXIiLCJvblBvcFN0YXRlIiwicmVsb2FkIiwiQUNUSU9OX1JFU1RPUkUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNvbnRlbnQiLCJGcmFnbWVudCIsIlBhdGhuYW1lQ29udGV4dCIsIlByb3ZpZGVyIiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJBcHBSb3V0ZXJDb250ZXh0IiwiTGF5b3V0Um91dGVyQ29udGV4dCIsImNoaWxkTm9kZXMiLCJfX2VzTW9kdWxlIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/error-boundary.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/error-boundary.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\n\nvar _inherits = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js\");\n\nvar _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js\");\n\nvar _getPrototypeOf = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ErrorBoundary = ErrorBoundary;\nexports.GlobalErrorComponent = GlobalErrorComponent;\n\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\n\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */\n\n\nvar ErrorBoundaryHandler = /*#__PURE__*/function (_react$default$Compon) {\n  _inherits(ErrorBoundaryHandler, _react$default$Compon);\n\n  var _super = _createSuper(ErrorBoundaryHandler);\n\n  function ErrorBoundaryHandler(props) {\n    var _this;\n\n    _classCallCheck(this, ErrorBoundaryHandler);\n\n    _this = _super.call(this, props);\n\n    _this.reset = function () {\n      _this.setState({\n        error: null\n      });\n    };\n\n    _this.state = {\n      error: null\n    };\n    return _this;\n  }\n\n  _createClass(ErrorBoundaryHandler, [{\n    key: \"render\",\n    value: function render() {\n      if (this.state.error) {\n        return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, this.props.errorStyles, /*#__PURE__*/_react[\"default\"].createElement(this.props.errorComponent, {\n          error: this.state.error,\n          reset: this.reset\n        }));\n      }\n\n      return this.props.children;\n    }\n  }], [{\n    key: \"getDerivedStateFromError\",\n    value: function getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    }\n  }]);\n\n  return ErrorBoundaryHandler;\n}(_react[\"default\"].Component);\n\nfunction ErrorBoundary(_ref) {\n  var errorComponent = _ref.errorComponent,\n      errorStyles = _ref.errorStyles,\n      children = _ref.children;\n\n  if (errorComponent) {\n    return /*#__PURE__*/_react[\"default\"].createElement(ErrorBoundaryHandler, {\n      errorComponent: errorComponent,\n      errorStyles: errorStyles\n    }, children);\n  }\n\n  return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, children);\n}\n\n_c = ErrorBoundary;\nvar styles = {\n  error: {\n    fontFamily: '-apple-system, BlinkMacSystemFont, Roboto, \"Segoe UI\", \"Fira Sans\", Avenir, \"Helvetica Neue\", \"Lucida Grande\", sans-serif',\n    height: '100vh',\n    textAlign: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center'\n  },\n  desc: {\n    display: 'inline-block',\n    textAlign: 'left',\n    lineHeight: '49px',\n    height: '49px',\n    verticalAlign: 'middle'\n  },\n  h2: {\n    fontSize: '14px',\n    fontWeight: 'normal',\n    lineHeight: '49px',\n    margin: 0,\n    padding: 0\n  }\n};\n\nfunction GlobalErrorComponent() {\n  return /*#__PURE__*/_react[\"default\"].createElement(\"html\", null, /*#__PURE__*/_react[\"default\"].createElement(\"body\", null, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n    style: styles.error\n  }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n    style: styles.desc\n  }, /*#__PURE__*/_react[\"default\"].createElement(\"h2\", {\n    style: styles.h2\n  }, \"Application error: a client-side exception has occurred (see the browser console for more information).\")))));\n}\n\n_c2 = GlobalErrorComponent;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"ErrorBoundary\");\n$RefreshReg$(_c2, \"GlobalErrorComponent\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7Ozs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELHFCQUFBLEdBQXdCRSxhQUF4QjtBQUNBRiw0QkFBQSxHQUErQkcsb0JBQS9COztBQUNBLElBQUlDLHdCQUF3QixHQUFHQyxtSkFBL0I7O0FBQ0EsSUFBSUMsTUFBTSxHQUFHRix3QkFBd0IsQ0FBQ0MsbUJBQU8sQ0FBQywrREFBRCxDQUFSLENBQXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztJQUFVRSxvQjs7Ozs7RUFlTiw4QkFBWUMsS0FBWixFQUFrQjtJQUFBOztJQUFBOztJQUNkLDBCQUFNQSxLQUFOOztJQUNBLE1BQUtDLEtBQUwsR0FBYSxZQUFJO01BQ2IsTUFBS0MsUUFBTCxDQUFjO1FBQ1ZDLEtBQUssRUFBRTtNQURHLENBQWQ7SUFHSCxDQUpEOztJQUtBLE1BQUtDLEtBQUwsR0FBYTtNQUNURCxLQUFLLEVBQUU7SUFERSxDQUFiO0lBUGM7RUFVakI7Ozs7V0FuQkQsa0JBQVM7TUFDTCxJQUFJLEtBQUtDLEtBQUwsQ0FBV0QsS0FBZixFQUFzQjtRQUNsQixPQUFPLGFBQWNMLE1BQU0sV0FBTixDQUFlTyxhQUFmLENBQTZCUCxNQUFNLFdBQU4sQ0FBZVEsUUFBNUMsRUFBc0QsSUFBdEQsRUFBNEQsS0FBS04sS0FBTCxDQUFXTyxXQUF2RSxFQUFvRixhQUFjVCxNQUFNLFdBQU4sQ0FBZU8sYUFBZixDQUE2QixLQUFLTCxLQUFMLENBQVdRLGNBQXhDLEVBQXdEO1VBQzNLTCxLQUFLLEVBQUUsS0FBS0MsS0FBTCxDQUFXRCxLQUR5SjtVQUUzS0YsS0FBSyxFQUFFLEtBQUtBO1FBRitKLENBQXhELENBQWxHLENBQXJCO01BSUg7O01BQ0QsT0FBTyxLQUFLRCxLQUFMLENBQVdTLFFBQWxCO0lBQ0g7OztX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b2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9lcnJvci1ib3VuZGFyeS5qcz83Njk3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5FcnJvckJvdW5kYXJ5ID0gRXJyb3JCb3VuZGFyeTtcbmV4cG9ydHMuR2xvYmFsRXJyb3JDb21wb25lbnQgPSBHbG9iYWxFcnJvckNvbXBvbmVudDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbi8qKlxuICogSGFuZGxlcyBlcnJvcnMgdGhyb3VnaCBgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yYC5cbiAqIFJlbmRlcnMgdGhlIHByb3ZpZGVkIGVycm9yIGNvbXBvbmVudCBhbmQgcHJvdmlkZXMgYSB3YXkgdG8gYHJlc2V0YCB0aGUgZXJyb3IgYm91bmRhcnkgc3RhdGUuXG4gKi8gY2xhc3MgRXJyb3JCb3VuZGFyeUhhbmRsZXIgZXh0ZW5kcyBfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIHRoaXMucHJvcHMuZXJyb3JTdHlsZXMsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudCh0aGlzLnByb3BzLmVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVzZXQ6IHRoaXMucmVzZXRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMucmVzZXQgPSAoKT0+e1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBFcnJvckJvdW5kYXJ5KHsgZXJyb3JDb21wb25lbnQgLCBlcnJvclN0eWxlcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgaWYgKGVycm9yQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeUhhbmRsZXIsIHtcbiAgICAgICAgICAgIGVycm9yQ29tcG9uZW50OiBlcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIGVycm9yU3R5bGVzOiBlcnJvclN0eWxlc1xuICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbmNvbnN0IHN0eWxlcyA9IHtcbiAgICBlcnJvcjoge1xuICAgICAgICBmb250RmFtaWx5OiAnLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBSb2JvdG8sIFwiU2Vnb2UgVUlcIiwgXCJGaXJhIFNhbnNcIiwgQXZlbmlyLCBcIkhlbHZldGljYSBOZXVlXCIsIFwiTHVjaWRhIEdyYW5kZVwiLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInXG4gICAgfSxcbiAgICBkZXNjOiB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgICAgbGluZUhlaWdodDogJzQ5cHgnLFxuICAgICAgICBoZWlnaHQ6ICc0OXB4JyxcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICB9LFxuICAgIGgyOiB7XG4gICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICBsaW5lSGVpZ2h0OiAnNDlweCcsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgcGFkZGluZzogMFxuICAgIH1cbn07XG5mdW5jdGlvbiBHbG9iYWxFcnJvckNvbXBvbmVudCgpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaHRtbFwiLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZXMuZXJyb3JcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLmRlc2NcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZXMuaDJcbiAgICB9LCBcIkFwcGxpY2F0aW9uIGVycm9yOiBhIGNsaWVudC1zaWRlIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQgKHNlZSB0aGUgYnJvd3NlciBjb25zb2xlIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cIikpKSkpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci1ib3VuZGFyeS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJFcnJvckJvdW5kYXJ5IiwiR2xvYmFsRXJyb3JDb21wb25lbnQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiRXJyb3JCb3VuZGFyeUhhbmRsZXIiLCJwcm9wcyIsInJlc2V0Iiwic2V0U3RhdGUiLCJlcnJvciIsInN0YXRlIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiZXJyb3JTdHlsZXMiLCJlcnJvckNvbXBvbmVudCIsImNoaWxkcmVuIiwiQ29tcG9uZW50Iiwic3R5bGVzIiwiZm9udEZhbWlseSIsImhlaWdodCIsInRleHRBbGlnbiIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwiZGVzYyIsImxpbmVIZWlnaHQiLCJ2ZXJ0aWNhbEFsaWduIiwiaDIiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJtYXJnaW4iLCJwYWRkaW5nIiwic3R5bGUiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/error-boundary.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/infinite-promise.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/infinite-promise.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createInfinitePromise = createInfinitePromise;\n/**\n * Used to cache in createInfinitePromise\n */\n\nvar infinitePromise;\n\nfunction createInfinitePromise() {\n  if (!infinitePromise) {\n    // Only create the Promise once\n    infinitePromise = new Promise(function () {// This is used to debug when the rendering is never updated.\n      // setTimeout(() => {\n      //   infinitePromise = new Error('Infinite promise')\n      //   resolve()\n      // }, 5000)\n    });\n  }\n\n  return infinitePromise;\n}\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2luZmluaXRlLXByb21pc2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELDZCQUFBLEdBQWdDRSxxQkFBaEM7QUFDQTtBQUNBO0FBQ0E7O0FBQUksSUFBSUMsZUFBSjs7QUFDSixTQUFTRCxxQkFBVCxHQUFpQztFQUM3QixJQUFJLENBQUNDLGVBQUwsRUFBc0I7SUFDbEI7SUFDQUEsZUFBZSxHQUFHLElBQUlDLE9BQUosQ0FBWSxZQUFJLENBQ2xDO01BQ0E7TUFDQTtNQUNBO01BQ0E7SUFDQyxDQU5pQixDQUFsQjtFQU9IOztFQUNELE9BQU9ELGVBQVA7QUFDSDs7QUFFRCxJQUFJLENBQUMsT0FBT0gsT0FBTyxXQUFkLEtBQTJCLFVBQTNCLElBQTBDLE9BQU9BLE9BQU8sV0FBZCxLQUEyQixRQUEzQixJQUF1Q0EsT0FBTyxXQUFQLEtBQW9CLElBQXRHLEtBQWdILE9BQU9BLE9BQU8sV0FBUCxDQUFnQkssVUFBdkIsS0FBc0MsV0FBMUosRUFBdUs7RUFDcktQLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsT0FBTyxXQUE3QixFQUF1QyxZQUF2QyxFQUFxRDtJQUFFQyxLQUFLLEVBQUU7RUFBVCxDQUFyRDtFQUNBSCxNQUFNLENBQUNRLE1BQVAsQ0FBY04sT0FBTyxXQUFyQixFQUErQkEsT0FBL0I7RUFDQU8sTUFBTSxDQUFDUCxPQUFQLEdBQWlCQSxPQUFPLFdBQXhCO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9pbmZpbml0ZS1wcm9taXNlLmpzPzcyZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZUluZmluaXRlUHJvbWlzZSA9IGNyZWF0ZUluZmluaXRlUHJvbWlzZTtcbi8qKlxuICogVXNlZCB0byBjYWNoZSBpbiBjcmVhdGVJbmZpbml0ZVByb21pc2VcbiAqLyBsZXQgaW5maW5pdGVQcm9taXNlO1xuZnVuY3Rpb24gY3JlYXRlSW5maW5pdGVQcm9taXNlKCkge1xuICAgIGlmICghaW5maW5pdGVQcm9taXNlKSB7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIHRoZSBQcm9taXNlIG9uY2VcbiAgICAgICAgaW5maW5pdGVQcm9taXNlID0gbmV3IFByb21pc2UoKCk9PntcbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIGRlYnVnIHdoZW4gdGhlIHJlbmRlcmluZyBpcyBuZXZlciB1cGRhdGVkLlxuICAgICAgICAvLyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gICBpbmZpbml0ZVByb21pc2UgPSBuZXcgRXJyb3IoJ0luZmluaXRlIHByb21pc2UnKVxuICAgICAgICAvLyAgIHJlc29sdmUoKVxuICAgICAgICAvLyB9LCA1MDAwKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGluZmluaXRlUHJvbWlzZTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5maW5pdGUtcHJvbWlzZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVJbmZpbml0ZVByb21pc2UiLCJpbmZpbml0ZVByb21pc2UiLCJQcm9taXNlIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/infinite-promise.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/layout-router.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/layout-router.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\"use client\";\n\"use strict\";\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\n\nvar _inherits = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js\");\n\nvar _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js\");\n\nvar _getPrototypeOf = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js\");\n\nvar _toConsumableArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray.js\");\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = OuterLayoutRouter;\nexports.InnerLayoutRouter = InnerLayoutRouter;\n\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\n\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\n\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\n\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\n\nvar _appRouter = __webpack_require__(/*! ./app-router */ \"./node_modules/next/dist/client/components/app-router.js\");\n\nvar _infinitePromise = __webpack_require__(/*! ./infinite-promise */ \"./node_modules/next/dist/client/components/infinite-promise.js\");\n\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"./node_modules/next/dist/client/components/error-boundary.js\");\n\nvar _matchSegments = __webpack_require__(/*! ./match-segments */ \"./node_modules/next/dist/client/components/match-segments.js\");\n\nvar _navigation = __webpack_require__(/*! ./navigation */ \"./node_modules/next/dist/client/components/navigation.js\");\n\nfunction OuterLayoutRouter(_ref) {\n  _s();\n\n  var parallelRouterKey = _ref.parallelRouterKey,\n      segmentPath = _ref.segmentPath,\n      childProp = _ref.childProp,\n      error = _ref.error,\n      errorStyles = _ref.errorStyles,\n      templateStyles = _ref.templateStyles,\n      loading = _ref.loading,\n      loadingStyles = _ref.loadingStyles,\n      hasLoading = _ref.hasLoading,\n      template = _ref.template,\n      notFound = _ref.notFound,\n      notFoundStyles = _ref.notFoundStyles,\n      rootLayoutIncluded = _ref.rootLayoutIncluded;\n  var context = (0, _react).useContext(_appRouterContext.LayoutRouterContext);\n\n  if (!context) {\n    throw new Error('invariant expected layout router to be mounted');\n  }\n\n  var childNodes = context.childNodes,\n      tree = context.tree,\n      url = context.url; // Get the current parallelRouter cache node\n\n  var childNodesForParallelRouter = childNodes.get(parallelRouterKey); // If the parallel router cache node does not exist yet, create it.\n  // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n\n  if (!childNodesForParallelRouter) {\n    childNodes.set(parallelRouterKey, new Map());\n    childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n  } // Get the active segment in the tree\n  // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n\n\n  var treeSegment = tree[1][parallelRouterKey][0];\n  var childPropSegment = Array.isArray(childProp.segment) ? childProp.segment[1] : childProp.segment; // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n\n  var currentChildSegment = Array.isArray(treeSegment) ? treeSegment[1] : treeSegment;\n  /**\n  * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n  */\n  // TODO-APP: Add handling of `<Offscreen>` when it's available.\n\n  var preservedSegments = [currentChildSegment];\n  return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, preservedSegments.map(function (preservedSegment) {\n    return (\n      /*\n      - Error boundary\n      - Only renders error boundary if error component is provided.\n      - Rendered for each segment to ensure they have their own error state.\n      - Loading boundary\n      - Only renders suspense boundary if loading components is provided.\n      - Rendered for each segment to ensure they have their own loading state.\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n      */\n\n      /*#__PURE__*/\n      _react[\"default\"].createElement(_appRouterContext.TemplateContext.Provider, {\n        key: preservedSegment,\n        value: /*#__PURE__*/_react[\"default\"].createElement(_errorBoundary.ErrorBoundary, {\n          errorComponent: error,\n          errorStyles: errorStyles\n        }, /*#__PURE__*/_react[\"default\"].createElement(LoadingBoundary, {\n          hasLoading: hasLoading,\n          loading: loading,\n          loadingStyles: loadingStyles\n        }, /*#__PURE__*/_react[\"default\"].createElement(NotFoundBoundary, {\n          notFound: notFound,\n          notFoundStyles: notFoundStyles\n        }, /*#__PURE__*/_react[\"default\"].createElement(RedirectBoundary, null, /*#__PURE__*/_react[\"default\"].createElement(InnerLayoutRouter, {\n          parallelRouterKey: parallelRouterKey,\n          url: url,\n          tree: tree,\n          childNodes: childNodesForParallelRouter,\n          childProp: childPropSegment === preservedSegment ? childProp : null,\n          segmentPath: segmentPath,\n          path: preservedSegment,\n          isActive: currentChildSegment === preservedSegment,\n          rootLayoutIncluded: rootLayoutIncluded\n        })))))\n      }, /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, templateStyles, template))\n    );\n  }));\n}\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */\n\n\n_s(OuterLayoutRouter, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n\n_c = OuterLayoutRouter;\n\nfunction walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n  if (segmentPathToWalk) {\n    var _segmentPathToWalk = _slicedToArray(segmentPathToWalk, 2),\n        segment = _segmentPathToWalk[0],\n        parallelRouteKey = _segmentPathToWalk[1];\n\n    var isLast = segmentPathToWalk.length === 2;\n\n    if ((0, _matchSegments).matchSegment(treeToRecreate[0], segment)) {\n      if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n        if (isLast) {\n          var subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n          return [treeToRecreate[0], _extends({}, treeToRecreate[1], _defineProperty({}, parallelRouteKey, [subTree[0], subTree[1], subTree[2], 'refetch']))];\n        }\n\n        return [treeToRecreate[0], _extends({}, treeToRecreate[1], _defineProperty({}, parallelRouteKey, walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])))];\n      }\n    }\n  }\n\n  return treeToRecreate;\n}\n/**\n * Check if the top of the HTMLElement is in the viewport.\n */\n\n\nfunction topOfElementInViewport(element) {\n  var rect = element.getBoundingClientRect();\n  return rect.top >= 0;\n}\n\nfunction InnerLayoutRouter(_ref2) {\n  _s2();\n\n  var parallelRouterKey = _ref2.parallelRouterKey,\n      url = _ref2.url,\n      childNodes = _ref2.childNodes,\n      childProp = _ref2.childProp,\n      segmentPath = _ref2.segmentPath,\n      tree = _ref2.tree,\n      path = _ref2.path,\n      rootLayoutIncluded = _ref2.rootLayoutIncluded;\n  var context = (0, _react).useContext(_appRouterContext.GlobalLayoutRouterContext);\n\n  if (!context) {\n    throw new Error('invariant global layout router not mounted');\n  }\n\n  var changeByServerResponse = context.changeByServerResponse,\n      fullTree = context.tree,\n      focusAndScrollRef = context.focusAndScrollRef;\n  var focusAndScrollElementRef = (0, _react).useRef(null);\n  (0, _react).useEffect(function () {\n    // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n    if (focusAndScrollRef.apply && focusAndScrollElementRef.current) {\n      // State is mutated to ensure that the focus and scroll is applied only once.\n      focusAndScrollRef.apply = false; // Set focus on the element\n\n      focusAndScrollElementRef.current.focus(); // Only scroll into viewport when the layout is not visible currently.\n\n      if (!topOfElementInViewport(focusAndScrollElementRef.current)) {\n        var htmlElement = document.documentElement;\n        var existing = htmlElement.style.scrollBehavior;\n        htmlElement.style.scrollBehavior = 'auto';\n        focusAndScrollElementRef.current.scrollIntoView();\n        htmlElement.style.scrollBehavior = existing;\n      }\n    }\n  }, [focusAndScrollRef]); // Read segment path from the parallel router cache node.\n\n  var childNode = childNodes.get(path); // If childProp is available this means it's the Flight / SSR case.\n\n  if (childProp && // TODO-APP: verify if this can be null based on user code\n  childProp.current !== null) {\n    if (childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED) {\n      // @ts-expect-error TODO-APP: handle changing of the type\n      childNode.status = _appRouterContext.CacheStates.READY; // @ts-expect-error TODO-APP: handle changing of the type\n\n      childNode.subTreeData = childProp.current; // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n\n      childProp.current = null;\n    } else {\n      // Add the segment's subTreeData to the cache.\n      // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n      childNodes.set(path, {\n        status: _appRouterContext.CacheStates.READY,\n        data: null,\n        subTreeData: childProp.current,\n        parallelRoutes: new Map()\n      }); // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n\n      childProp.current = null; // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n\n      childNode = childNodes.get(path);\n    }\n  } // When childNode is not available during rendering client-side we need to fetch it from the server.\n\n\n  if (!childNode || childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED) {\n    /**\n    * Router state with refetch marker added\n    */\n    // TODO-APP: remove ''\n    var refetchTree = walkAddRefetch([''].concat(_toConsumableArray(segmentPath)), fullTree);\n    /**\n    * Flight data fetch kicked off during render and put into the cache.\n    */\n\n    childNodes.set(path, {\n      status: _appRouterContext.CacheStates.DATA_FETCH,\n      data: (0, _appRouter).fetchServerResponse(new URL(url, location.origin), refetchTree),\n      subTreeData: null,\n      head: childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED ? childNode.head : undefined,\n      parallelRoutes: childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED ? childNode.parallelRoutes : new Map()\n    }); // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n\n    childNode = childNodes.get(path);\n  } // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n\n\n  if (!childNode) {\n    throw new Error('Child node should always exist');\n  } // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n\n\n  if (childNode.subTreeData && childNode.data) {\n    throw new Error('Child node should not have both subTreeData and data');\n  } // If cache node has a data request we have to unwrap response by `use` and update the cache.\n\n\n  if (childNode.data) {\n    // TODO-APP: error case\n\n    /**\n    * Flight response data\n    */\n    // When the data has not resolved yet `use` will suspend here.\n    var _use = (0, _react).use(childNode.data),\n        _use2 = _slicedToArray(_use, 2),\n        flightData = _use2[0],\n        overrideCanonicalUrl = _use2[1]; // Handle case when navigating to page in `pages` from `app`\n\n\n    if (typeof flightData === 'string') {\n      window.location.href = url;\n      return null;\n    } // segmentPath from the server does not match the layout's segmentPath\n\n\n    childNode.data = null; // setTimeout is used to start a new transition during render, this is an intentional hack around React.\n\n    setTimeout(function () {\n      // @ts-ignore startTransition exists\n      _react[\"default\"].startTransition(function () {\n        // TODO-APP: handle redirect\n        changeByServerResponse(fullTree, flightData, overrideCanonicalUrl);\n      });\n    }); // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n\n    (0, _react).use((0, _infinitePromise).createInfinitePromise());\n  } // If cache node has no subTreeData and no data request we have to infinitely suspend as the data will likely flow in from another place.\n  // TODO-APP: double check users can't return null in a component that will kick in here.\n\n\n  if (!childNode.subTreeData) {\n    (0, _react).use((0, _infinitePromise).createInfinitePromise());\n  }\n\n  var subtree = // The layout router context narrows down tree and childNodes at each level.\n\n  /*#__PURE__*/\n  _react[\"default\"].createElement(_appRouterContext.LayoutRouterContext.Provider, {\n    value: {\n      tree: tree[1][parallelRouterKey],\n      childNodes: childNode.parallelRoutes,\n      // TODO-APP: overriding of url for parallel routes\n      url: url\n    }\n  }, childNode.subTreeData); // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n\n\n  return rootLayoutIncluded ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n    ref: focusAndScrollElementRef,\n    \"data-nextjs-scroll-focus-boundary\": ''\n  }, subtree) : subtree;\n}\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */\n\n\n_s2(InnerLayoutRouter, \"JQanpc2hF1A904pZOh54fuThoYw=\");\n\n_c2 = InnerLayoutRouter;\n\nfunction LoadingBoundary(_ref3) {\n  var children = _ref3.children,\n      loading = _ref3.loading,\n      loadingStyles = _ref3.loadingStyles,\n      hasLoading = _ref3.hasLoading;\n\n  if (hasLoading) {\n    return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Suspense, {\n      fallback: /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, loadingStyles, loading)\n    }, children);\n  }\n\n  return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, children);\n}\n\n_c3 = LoadingBoundary;\n\nfunction HandleRedirect(_ref4) {\n  _s3();\n\n  var redirect = _ref4.redirect;\n  var router = (0, _navigation).useRouter();\n  (0, _react).useEffect(function () {\n    router.replace(redirect, {});\n  }, [redirect, router]);\n  return null;\n}\n\n_s3(HandleRedirect, \"vQduR7x+OPXj6PSmJyFnf+hU7bg=\", true);\n\n_c4 = HandleRedirect;\n\nvar RedirectErrorBoundary = /*#__PURE__*/function (_react$default$Compon) {\n  _inherits(RedirectErrorBoundary, _react$default$Compon);\n\n  var _super = _createSuper(RedirectErrorBoundary);\n\n  function RedirectErrorBoundary(props) {\n    var _this;\n\n    _classCallCheck(this, RedirectErrorBoundary);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      redirect: null\n    };\n    return _this;\n  }\n\n  _createClass(RedirectErrorBoundary, [{\n    key: \"render\",\n    value: function render() {\n      var redirect = this.state.redirect;\n\n      if (redirect !== null) {\n        return /*#__PURE__*/_react[\"default\"].createElement(HandleRedirect, {\n          redirect: redirect\n        });\n      }\n\n      return this.props.children;\n    }\n  }], [{\n    key: \"getDerivedStateFromError\",\n    value: function getDerivedStateFromError(error) {\n      var ref;\n\n      if ((ref = error.digest) == null ? void 0 : ref.startsWith('NEXT_REDIRECT')) {\n        var url = error.digest.split(';')[1];\n        return {\n          redirect: url\n        };\n      } // Re-throw if error is not for redirect\n\n\n      throw error;\n    }\n  }]);\n\n  return RedirectErrorBoundary;\n}(_react[\"default\"].Component);\n\nfunction RedirectBoundary(_ref5) {\n  _s4();\n\n  var children = _ref5.children;\n  var router = (0, _navigation).useRouter();\n  return /*#__PURE__*/_react[\"default\"].createElement(RedirectErrorBoundary, {\n    router: router\n  }, children);\n}\n\n_s4(RedirectBoundary, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\", true);\n\n_c5 = RedirectBoundary;\n\nvar NotFoundErrorBoundary = /*#__PURE__*/function (_react$default$Compon2) {\n  _inherits(NotFoundErrorBoundary, _react$default$Compon2);\n\n  var _super2 = _createSuper(NotFoundErrorBoundary);\n\n  function NotFoundErrorBoundary(props) {\n    var _this2;\n\n    _classCallCheck(this, NotFoundErrorBoundary);\n\n    _this2 = _super2.call(this, props);\n    _this2.state = {\n      notFoundTriggered: false\n    };\n    return _this2;\n  }\n\n  _createClass(NotFoundErrorBoundary, [{\n    key: \"render\",\n    value: function render() {\n      if (this.state.notFoundTriggered) {\n        return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, /*#__PURE__*/_react[\"default\"].createElement(\"meta\", {\n          name: \"robots\",\n          content: \"noindex\"\n        }), this.props.notFoundStyles, this.props.notFound);\n      }\n\n      return this.props.children;\n    }\n  }], [{\n    key: \"getDerivedStateFromError\",\n    value: function getDerivedStateFromError(error) {\n      if (error.digest === 'NEXT_NOT_FOUND') {\n        return {\n          notFoundTriggered: true\n        };\n      } // Re-throw if error is not for 404\n\n\n      throw error;\n    }\n  }]);\n\n  return NotFoundErrorBoundary;\n}(_react[\"default\"].Component);\n\nfunction NotFoundBoundary(_ref6) {\n  var notFound = _ref6.notFound,\n      notFoundStyles = _ref6.notFoundStyles,\n      children = _ref6.children;\n  return notFound ? /*#__PURE__*/_react[\"default\"].createElement(NotFoundErrorBoundary, {\n    notFound: notFound,\n    notFoundStyles: notFoundStyles\n  }, children) : /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, children);\n}\n\n_c6 = NotFoundBoundary;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\nvar _c, _c2, _c3, _c4, _c5, _c6;\n\n$RefreshReg$(_c, \"OuterLayoutRouter\");\n$RefreshReg$(_c2, \"InnerLayoutRouter\");\n$RefreshReg$(_c3, \"LoadingBoundary\");\n$RefreshReg$(_c4, \"HandleRedirect\");\n$RefreshReg$(_c5, \"RedirectBoundary\");\n$RefreshReg$(_c6, \"NotFoundBoundary\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0FBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELGtCQUFBLEdBQWtCRSxpQkFBbEI7QUFDQUYseUJBQUEsR0FBNEJHLGlCQUE1Qjs7QUFDQSxJQUFJQyxRQUFRLEdBQUdDLG1IQUFmOztBQUNBLElBQUlDLHlCQUF5QixHQUFHRCxxSkFBaEM7O0FBQ0EsSUFBSUUsTUFBTSxHQUFHRCx5QkFBeUIsQ0FBQ0QsbUJBQU8sQ0FBQywrREFBRCxDQUFSLENBQXRDOztBQUNBLElBQUlHLGlCQUFpQixHQUFHSCxtQkFBTyxDQUFDLHNHQUFELENBQS9COztBQUNBLElBQUlJLFVBQVUsR0FBR0osbUJBQU8sQ0FBQyw4RUFBRCxDQUF4Qjs7QUFDQSxJQUFJSyxnQkFBZ0IsR0FBR0wsbUJBQU8sQ0FBQywwRkFBRCxDQUE5Qjs7QUFDQSxJQUFJTSxjQUFjLEdBQUdOLG1CQUFPLENBQUMsc0ZBQUQsQ0FBNUI7O0FBQ0EsSUFBSU8sY0FBYyxHQUFHUCxtQkFBTyxDQUFDLHNGQUFELENBQTVCOztBQUNBLElBQUlRLFdBQVcsR0FBR1IsbUJBQU8sQ0FBQyw4RUFBRCxDQUF6Qjs7QUFDQSxTQUFTSCxpQkFBVCxPQUF1TjtFQUFBOztFQUFBLElBQTFMWSxpQkFBMEwsUUFBMUxBLGlCQUEwTDtFQUFBLElBQXRLQyxXQUFzSyxRQUF0S0EsV0FBc0s7RUFBQSxJQUF4SkMsU0FBd0osUUFBeEpBLFNBQXdKO0VBQUEsSUFBNUlDLEtBQTRJLFFBQTVJQSxLQUE0STtFQUFBLElBQXBJQyxXQUFvSSxRQUFwSUEsV0FBb0k7RUFBQSxJQUF0SEMsY0FBc0gsUUFBdEhBLGNBQXNIO0VBQUEsSUFBckdDLE9BQXFHLFFBQXJHQSxPQUFxRztFQUFBLElBQTNGQyxhQUEyRixR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QixFQUErQkEsT0FBL0I7RUFDQTBJLE1BQU0sQ0FBQzFJLE9BQVAsR0FBaUJBLE9BQU8sV0FBeEI7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanM/MGJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gT3V0ZXJMYXlvdXRSb3V0ZXI7XG5leHBvcnRzLklubmVyTGF5b3V0Um91dGVyID0gSW5uZXJMYXlvdXRSb3V0ZXI7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xudmFyIF9hcHBSb3V0ZXIgPSByZXF1aXJlKFwiLi9hcHAtcm91dGVyXCIpO1xudmFyIF9pbmZpbml0ZVByb21pc2UgPSByZXF1aXJlKFwiLi9pbmZpbml0ZS1wcm9taXNlXCIpO1xudmFyIF9lcnJvckJvdW5kYXJ5ID0gcmVxdWlyZShcIi4vZXJyb3ItYm91bmRhcnlcIik7XG52YXIgX21hdGNoU2VnbWVudHMgPSByZXF1aXJlKFwiLi9tYXRjaC1zZWdtZW50c1wiKTtcbnZhciBfbmF2aWdhdGlvbiA9IHJlcXVpcmUoXCIuL25hdmlnYXRpb25cIik7XG5mdW5jdGlvbiBPdXRlckxheW91dFJvdXRlcih7IHBhcmFsbGVsUm91dGVyS2V5ICwgc2VnbWVudFBhdGggLCBjaGlsZFByb3AgLCBlcnJvciAsIGVycm9yU3R5bGVzICwgdGVtcGxhdGVTdHlsZXMgLCBsb2FkaW5nICwgbG9hZGluZ1N0eWxlcyAsIGhhc0xvYWRpbmcgLCB0ZW1wbGF0ZSAsIG5vdEZvdW5kICwgbm90Rm91bmRTdHlsZXMgLCByb290TGF5b3V0SW5jbHVkZWQgIH0pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfYXBwUm91dGVyQ29udGV4dC5MYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZXhwZWN0ZWQgbGF5b3V0IHJvdXRlciB0byBiZSBtb3VudGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2hpbGROb2RlcyAsIHRyZWUgLCB1cmwgIH0gPSBjb250ZXh0O1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBwYXJhbGxlbFJvdXRlciBjYWNoZSBub2RlXG4gICAgbGV0IGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlciA9IGNoaWxkTm9kZXMuZ2V0KHBhcmFsbGVsUm91dGVyS2V5KTtcbiAgICAvLyBJZiB0aGUgcGFyYWxsZWwgcm91dGVyIGNhY2hlIG5vZGUgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuXG4gICAgLy8gVGhpcyB3cml0ZXMgdG8gdGhlIGNhY2hlIHdoZW4gdGhlcmUgaXMgbm8gaXRlbSBpbiB0aGUgY2FjaGUgeWV0LiBJdCBuZXZlciAqb3ZlcndyaXRlcyogZXhpc3RpbmcgY2FjaGUgaXRlbXMgd2hpY2ggaXMgd2h5IGl0J3Mgc2FmZSBpbiBjb25jdXJyZW50IG1vZGUuXG4gICAgaWYgKCFjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5zZXQocGFyYWxsZWxSb3V0ZXJLZXksIG5ldyBNYXAoKSk7XG4gICAgICAgIGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlciA9IGNoaWxkTm9kZXMuZ2V0KHBhcmFsbGVsUm91dGVyS2V5KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBhY3RpdmUgc2VnbWVudCBpbiB0aGUgdHJlZVxuICAgIC8vIFRoZSByZWFzb24gYXJyYXlzIGFyZSB1c2VkIGluIHRoZSBkYXRhIGZvcm1hdCBpcyB0aGF0IHRoZXNlIGFyZSB0cmFuc2ZlcnJlZCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGJyb3dzZXIgc28gaXQncyBvcHRpbWl6ZWQgdG8gc2F2ZSBieXRlcy5cbiAgICBjb25zdCB0cmVlU2VnbWVudCA9IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldWzBdO1xuICAgIGNvbnN0IGNoaWxkUHJvcFNlZ21lbnQgPSBBcnJheS5pc0FycmF5KGNoaWxkUHJvcC5zZWdtZW50KSA/IGNoaWxkUHJvcC5zZWdtZW50WzFdIDogY2hpbGRQcm9wLnNlZ21lbnQ7XG4gICAgLy8gSWYgc2VnbWVudCBpcyBhbiBhcnJheSBpdCdzIGEgZHluYW1pYyByb3V0ZSBhbmQgd2Ugd2FudCB0byByZWFkIHRoZSBkeW5hbWljIHJvdXRlIHZhbHVlIGFzIHRoZSBzZWdtZW50IHRvIGdldCBmcm9tIHRoZSBjYWNoZS5cbiAgICBjb25zdCBjdXJyZW50Q2hpbGRTZWdtZW50ID0gQXJyYXkuaXNBcnJheSh0cmVlU2VnbWVudCkgPyB0cmVlU2VnbWVudFsxXSA6IHRyZWVTZWdtZW50O1xuICAgIC8qKlxuICAgKiBEZWNpZGVzIHdoaWNoIHNlZ21lbnRzIHRvIGtlZXAgcmVuZGVyaW5nLCBhbGwgc2VnbWVudHMgdGhhdCBhcmUgbm90IGFjdGl2ZSB3aWxsIGJlIHdyYXBwZWQgaW4gYDxPZmZzY3JlZW4+YC5cbiAgICovIC8vIFRPRE8tQVBQOiBBZGQgaGFuZGxpbmcgb2YgYDxPZmZzY3JlZW4+YCB3aGVuIGl0J3MgYXZhaWxhYmxlLlxuICAgIGNvbnN0IHByZXNlcnZlZFNlZ21lbnRzID0gW1xuICAgICAgICBjdXJyZW50Q2hpbGRTZWdtZW50XG4gICAgXTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBwcmVzZXJ2ZWRTZWdtZW50cy5tYXAoKHByZXNlcnZlZFNlZ21lbnQpPT57XG4gICAgICAgIHJldHVybigvKlxuICAgICAgICAgICAgLSBFcnJvciBib3VuZGFyeVxuICAgICAgICAgICAgICAtIE9ubHkgcmVuZGVycyBlcnJvciBib3VuZGFyeSBpZiBlcnJvciBjb21wb25lbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC0gUmVuZGVyZWQgZm9yIGVhY2ggc2VnbWVudCB0byBlbnN1cmUgdGhleSBoYXZlIHRoZWlyIG93biBlcnJvciBzdGF0ZS5cbiAgICAgICAgICAgIC0gTG9hZGluZyBib3VuZGFyeVxuICAgICAgICAgICAgICAtIE9ubHkgcmVuZGVycyBzdXNwZW5zZSBib3VuZGFyeSBpZiBsb2FkaW5nIGNvbXBvbmVudHMgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC0gUmVuZGVyZWQgZm9yIGVhY2ggc2VnbWVudCB0byBlbnN1cmUgdGhleSBoYXZlIHRoZWlyIG93biBsb2FkaW5nIHN0YXRlLlxuICAgICAgICAgICAgICAtIFBhc3NlZCB0byB0aGUgcm91dGVyIGR1cmluZyByZW5kZXJpbmcgdG8gZW5zdXJlIGl0IGNhbiBiZSBpbW1lZGlhdGVseSByZW5kZXJlZCB3aGVuIHN1c3BlbmRpbmcgb24gYSBGbGlnaHQgZmV0Y2guXG4gICAgICAgICAgKi8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LlRlbXBsYXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAga2V5OiBwcmVzZXJ2ZWRTZWdtZW50LFxuICAgICAgICAgICAgdmFsdWU6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfZXJyb3JCb3VuZGFyeS5FcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgZXJyb3JDb21wb25lbnQ6IGVycm9yLFxuICAgICAgICAgICAgICAgIGVycm9yU3R5bGVzOiBlcnJvclN0eWxlc1xuICAgICAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KExvYWRpbmdCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgIGhhc0xvYWRpbmc6IGhhc0xvYWRpbmcsXG4gICAgICAgICAgICAgICAgbG9hZGluZzogbG9hZGluZyxcbiAgICAgICAgICAgICAgICBsb2FkaW5nU3R5bGVzOiBsb2FkaW5nU3R5bGVzXG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTm90Rm91bmRCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgIG5vdEZvdW5kOiBub3RGb3VuZCxcbiAgICAgICAgICAgICAgICBub3RGb3VuZFN0eWxlczogbm90Rm91bmRTdHlsZXNcbiAgICAgICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSZWRpcmVjdEJvdW5kYXJ5LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSW5uZXJMYXlvdXRSb3V0ZXIsIHtcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlcktleTogcGFyYWxsZWxSb3V0ZXJLZXksXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgdHJlZTogdHJlZSxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIsXG4gICAgICAgICAgICAgICAgY2hpbGRQcm9wOiBjaGlsZFByb3BTZWdtZW50ID09PSBwcmVzZXJ2ZWRTZWdtZW50ID8gY2hpbGRQcm9wIDogbnVsbCxcbiAgICAgICAgICAgICAgICBzZWdtZW50UGF0aDogc2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgcGF0aDogcHJlc2VydmVkU2VnbWVudCxcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogY3VycmVudENoaWxkU2VnbWVudCA9PT0gcHJlc2VydmVkU2VnbWVudCxcbiAgICAgICAgICAgICAgICByb290TGF5b3V0SW5jbHVkZWQ6IHJvb3RMYXlvdXRJbmNsdWRlZFxuICAgICAgICAgICAgfSkpKSkpXG4gICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgdGVtcGxhdGVTdHlsZXMsIHRlbXBsYXRlKSkpO1xuICAgIH0pKTtcbn1cblxuLyoqXG4gKiBBZGQgcmVmZXRjaCBtYXJrZXIgdG8gcm91dGVyIHN0YXRlIGF0IHRoZSBwb2ludCBvZiB0aGUgY3VycmVudCBsYXlvdXQgc2VnbWVudC5cbiAqIFRoaXMgZW5zdXJlcyB0aGUgcmVzcG9uc2UgcmV0dXJuZWQgaXMgbm90IGZ1cnRoZXIgZG93biB0aGFuIHRoZSBjdXJyZW50IGxheW91dCBzZWdtZW50LlxuICovIGZ1bmN0aW9uIHdhbGtBZGRSZWZldGNoKHNlZ21lbnRQYXRoVG9XYWxrLCB0cmVlVG9SZWNyZWF0ZSkge1xuICAgIGlmIChzZWdtZW50UGF0aFRvV2Fsaykge1xuICAgICAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZUtleV0gPSBzZWdtZW50UGF0aFRvV2FsaztcbiAgICAgICAgY29uc3QgaXNMYXN0ID0gc2VnbWVudFBhdGhUb1dhbGsubGVuZ3RoID09PSAyO1xuICAgICAgICBpZiAoKDAsIF9tYXRjaFNlZ21lbnRzKS5tYXRjaFNlZ21lbnQodHJlZVRvUmVjcmVhdGVbMF0sIHNlZ21lbnQpKSB7XG4gICAgICAgICAgICBpZiAodHJlZVRvUmVjcmVhdGVbMV0uaGFzT3duUHJvcGVydHkocGFyYWxsZWxSb3V0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSB3YWxrQWRkUmVmZXRjaCh1bmRlZmluZWQsIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2V4dGVuZHMoe30sIHRyZWVUb1JlY3JlYXRlWzFdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcmFsbGVsUm91dGVLZXldOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWVbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZWZldGNoJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0cmVlVG9SZWNyZWF0ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgX2V4dGVuZHMoe30sIHRyZWVUb1JlY3JlYXRlWzFdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbcGFyYWxsZWxSb3V0ZUtleV06IHdhbGtBZGRSZWZldGNoKHNlZ21lbnRQYXRoVG9XYWxrLnNsaWNlKDIpLCB0cmVlVG9SZWNyZWF0ZVsxXVtwYXJhbGxlbFJvdXRlS2V5XSlcbiAgICAgICAgICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyZWVUb1JlY3JlYXRlO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdG9wIG9mIHRoZSBIVE1MRWxlbWVudCBpcyBpbiB0aGUgdmlld3BvcnQuXG4gKi8gZnVuY3Rpb24gdG9wT2ZFbGVtZW50SW5WaWV3cG9ydChlbGVtZW50KSB7XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHJlY3QudG9wID49IDA7XG59XG5mdW5jdGlvbiBJbm5lckxheW91dFJvdXRlcih7IHBhcmFsbGVsUm91dGVyS2V5ICwgdXJsICwgY2hpbGROb2RlcyAsIGNoaWxkUHJvcCAsIHNlZ21lbnRQYXRoICwgdHJlZSAsIC8vIFRPRE8tQVBQOiBpbXBsZW1lbnQgYDxPZmZzY3JlZW4+YCB3aGVuIGF2YWlsYWJsZS5cbi8vIGlzQWN0aXZlLFxucGF0aCAsIHJvb3RMYXlvdXRJbmNsdWRlZCAgfSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSAoMCwgX3JlYWN0KS51c2VDb250ZXh0KF9hcHBSb3V0ZXJDb250ZXh0Lkdsb2JhbExheW91dFJvdXRlckNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBnbG9iYWwgbGF5b3V0IHJvdXRlciBub3QgbW91bnRlZCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UgLCB0cmVlOiBmdWxsVHJlZSAsIGZvY3VzQW5kU2Nyb2xsUmVmICB9ID0gY29udGV4dDtcbiAgICBjb25zdCBmb2N1c0FuZFNjcm9sbEVsZW1lbnRSZWYgPSAoMCwgX3JlYWN0KS51c2VSZWYobnVsbCk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIC8vIEhhbmRsZSBzY3JvbGwgYW5kIGZvY3VzLCBpdCdzIG9ubHkgYXBwbGllZCBvbmNlIGluIHRoZSBmaXJzdCB1c2VFZmZlY3QgdGhhdCB0cmlnZ2VycyB0aGF0IGNoYW5nZWQuXG4gICAgICAgIGlmIChmb2N1c0FuZFNjcm9sbFJlZi5hcHBseSAmJiBmb2N1c0FuZFNjcm9sbEVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gU3RhdGUgaXMgbXV0YXRlZCB0byBlbnN1cmUgdGhhdCB0aGUgZm9jdXMgYW5kIHNjcm9sbCBpcyBhcHBsaWVkIG9ubHkgb25jZS5cbiAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBTZXQgZm9jdXMgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsRWxlbWVudFJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAvLyBPbmx5IHNjcm9sbCBpbnRvIHZpZXdwb3J0IHdoZW4gdGhlIGxheW91dCBpcyBub3QgdmlzaWJsZSBjdXJyZW50bHkuXG4gICAgICAgICAgICBpZiAoIXRvcE9mRWxlbWVudEluVmlld3BvcnQoZm9jdXNBbmRTY3JvbGxFbGVtZW50UmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHRtbEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvcjtcbiAgICAgICAgICAgICAgICBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbEVsZW1lbnRSZWYuY3VycmVudC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gZXhpc3Rpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmXG4gICAgXSk7XG4gICAgLy8gUmVhZCBzZWdtZW50IHBhdGggZnJvbSB0aGUgcGFyYWxsZWwgcm91dGVyIGNhY2hlIG5vZGUuXG4gICAgbGV0IGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KHBhdGgpO1xuICAgIC8vIElmIGNoaWxkUHJvcCBpcyBhdmFpbGFibGUgdGhpcyBtZWFucyBpdCdzIHRoZSBGbGlnaHQgLyBTU1IgY2FzZS5cbiAgICBpZiAoY2hpbGRQcm9wICYmIC8vIFRPRE8tQVBQOiB2ZXJpZnkgaWYgdGhpcyBjYW4gYmUgbnVsbCBiYXNlZCBvbiB1c2VyIGNvZGVcbiAgICBjaGlsZFByb3AuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETy1BUFA6IGhhbmRsZSBjaGFuZ2luZyBvZiB0aGUgdHlwZVxuICAgICAgICAgICAgY2hpbGROb2RlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPLUFQUDogaGFuZGxlIGNoYW5naW5nIG9mIHRoZSB0eXBlXG4gICAgICAgICAgICBjaGlsZE5vZGUuc3ViVHJlZURhdGEgPSBjaGlsZFByb3AuY3VycmVudDtcbiAgICAgICAgICAgIC8vIE11dGF0ZXMgdGhlIHByb3AgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhlIG1lbW9yeSBhc3NvY2lhdGVkIHdpdGggdGhlIHN1YlRyZWVEYXRhIGFzIGl0IGlzIG5vdyBwYXJ0IG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGNoaWxkUHJvcC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgc2VnbWVudCdzIHN1YlRyZWVEYXRhIHRvIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIC8vIFRoaXMgd3JpdGVzIHRvIHRoZSBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vIGl0ZW0gaW4gdGhlIGNhY2hlIHlldC4gSXQgbmV2ZXIgKm92ZXJ3cml0ZXMqIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIHdoaWNoIGlzIHdoeSBpdCdzIHNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICAgICAgICAgICAgY2hpbGROb2Rlcy5zZXQocGF0aCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFksXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRQcm9wLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBNdXRhdGVzIHRoZSBwcm9wIGluIG9yZGVyIHRvIGNsZWFuIHVwIHRoZSBtZW1vcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBzdWJUcmVlRGF0YSBhcyBpdCBpcyBub3cgcGFydCBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICBjaGlsZFByb3AuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBJbiB0aGUgYWJvdmUgY2FzZSBjaGlsZE5vZGUgd2FzIHNldCBvbiBjaGlsZE5vZGVzLCBzbyB3ZSBoYXZlIHRvIGdldCBpdCBmcm9tIHRoZSBjYWNoZU5vZGVzIGFnYWluLlxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2hlbiBjaGlsZE5vZGUgaXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgcmVuZGVyaW5nIGNsaWVudC1zaWRlIHdlIG5lZWQgdG8gZmV0Y2ggaXQgZnJvbSB0aGUgc2VydmVyLlxuICAgIGlmICghY2hpbGROb2RlIHx8IGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQpIHtcbiAgICAgICAgLyoqXG4gICAgICogUm91dGVyIHN0YXRlIHdpdGggcmVmZXRjaCBtYXJrZXIgYWRkZWRcbiAgICAgKi8gLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICBjb25zdCByZWZldGNoVHJlZSA9IHdhbGtBZGRSZWZldGNoKFtcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgLi4uc2VnbWVudFBhdGhcbiAgICAgICAgXSwgZnVsbFRyZWUpO1xuICAgICAgICAvKipcbiAgICAgKiBGbGlnaHQgZGF0YSBmZXRjaCBraWNrZWQgb2ZmIGR1cmluZyByZW5kZXIgYW5kIHB1dCBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKi8gY2hpbGROb2Rlcy5zZXQocGF0aCwge1xuICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5EQVRBX0ZFVENILFxuICAgICAgICAgICAgZGF0YTogKDAsIF9hcHBSb3V0ZXIpLmZldGNoU2VydmVyUmVzcG9uc2UobmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbiksIHJlZmV0Y2hUcmVlKSxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgaGVhZDogY2hpbGROb2RlICYmIGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQgPyBjaGlsZE5vZGUuaGVhZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLnN0YXR1cyA9PT0gX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuTEFaWV9JTklUSUFMSVpFRCA/IGNoaWxkTm9kZS5wYXJhbGxlbFJvdXRlcyA6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSW4gdGhlIGFib3ZlIGNhc2UgY2hpbGROb2RlIHdhcyBzZXQgb24gY2hpbGROb2Rlcywgc28gd2UgaGF2ZSB0byBnZXQgaXQgZnJvbSB0aGUgY2FjaGVOb2RlcyBhZ2Fpbi5cbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQocGF0aCk7XG4gICAgfVxuICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgaGFwcGVuIHNvIGl0IHRocm93cyBhbiBlcnJvci4gSXQgaW5kaWNhdGVzIHRoZXJlJ3MgYSBidWcgaW4gdGhlIE5leHQuanMuXG4gICAgaWYgKCFjaGlsZE5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZCBub2RlIHNob3VsZCBhbHdheXMgZXhpc3QnKTtcbiAgICB9XG4gICAgLy8gVGhpcyBjYXNlIHNob3VsZCBuZXZlciBoYXBwZW4gc28gaXQgdGhyb3dzIGFuIGVycm9yLiBJdCBpbmRpY2F0ZXMgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgTmV4dC5qcy5cbiAgICBpZiAoY2hpbGROb2RlLnN1YlRyZWVEYXRhICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgbm9kZSBzaG91bGQgbm90IGhhdmUgYm90aCBzdWJUcmVlRGF0YSBhbmQgZGF0YScpO1xuICAgIH1cbiAgICAvLyBJZiBjYWNoZSBub2RlIGhhcyBhIGRhdGEgcmVxdWVzdCB3ZSBoYXZlIHRvIHVud3JhcCByZXNwb25zZSBieSBgdXNlYCBhbmQgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgICAgLy8gVE9ETy1BUFA6IGVycm9yIGNhc2VcbiAgICAgICAgLyoqXG4gICAgICogRmxpZ2h0IHJlc3BvbnNlIGRhdGFcbiAgICAgKi8gLy8gV2hlbiB0aGUgZGF0YSBoYXMgbm90IHJlc29sdmVkIHlldCBgdXNlYCB3aWxsIHN1c3BlbmQgaGVyZS5cbiAgICAgICAgY29uc3QgW2ZsaWdodERhdGEsIG92ZXJyaWRlQ2Fub25pY2FsVXJsXSA9ICgwLCBfcmVhY3QpLnVzZShjaGlsZE5vZGUuZGF0YSk7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlZ21lbnRQYXRoIGZyb20gdGhlIHNlcnZlciBkb2VzIG5vdCBtYXRjaCB0aGUgbGF5b3V0J3Mgc2VnbWVudFBhdGhcbiAgICAgICAgY2hpbGROb2RlLmRhdGEgPSBudWxsO1xuICAgICAgICAvLyBzZXRUaW1lb3V0IGlzIHVzZWQgdG8gc3RhcnQgYSBuZXcgdHJhbnNpdGlvbiBkdXJpbmcgcmVuZGVyLCB0aGlzIGlzIGFuIGludGVudGlvbmFsIGhhY2sgYXJvdW5kIFJlYWN0LlxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgcmVkaXJlY3RcbiAgICAgICAgICAgICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlKGZ1bGxUcmVlLCBmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN1c3BlbmQgaW5maW5pdGVseSBhcyBgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZWAgd2lsbCBjYXVzZSBhIGRpZmZlcmVudCBwYXJ0IG9mIHRoZSB0cmVlIHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAoMCwgX3JlYWN0KS51c2UoKDAsIF9pbmZpbml0ZVByb21pc2UpLmNyZWF0ZUluZmluaXRlUHJvbWlzZSgpKTtcbiAgICB9XG4gICAgLy8gSWYgY2FjaGUgbm9kZSBoYXMgbm8gc3ViVHJlZURhdGEgYW5kIG5vIGRhdGEgcmVxdWVzdCB3ZSBoYXZlIHRvIGluZmluaXRlbHkgc3VzcGVuZCBhcyB0aGUgZGF0YSB3aWxsIGxpa2VseSBmbG93IGluIGZyb20gYW5vdGhlciBwbGFjZS5cbiAgICAvLyBUT0RPLUFQUDogZG91YmxlIGNoZWNrIHVzZXJzIGNhbid0IHJldHVybiBudWxsIGluIGEgY29tcG9uZW50IHRoYXQgd2lsbCBraWNrIGluIGhlcmUuXG4gICAgaWYgKCFjaGlsZE5vZGUuc3ViVHJlZURhdGEpIHtcbiAgICAgICAgKDAsIF9yZWFjdCkudXNlKCgwLCBfaW5maW5pdGVQcm9taXNlKS5jcmVhdGVJbmZpbml0ZVByb21pc2UoKSk7XG4gICAgfVxuICAgIGNvbnN0IHN1YnRyZWUgPSAvLyBUaGUgbGF5b3V0IHJvdXRlciBjb250ZXh0IG5hcnJvd3MgZG93biB0cmVlIGFuZCBjaGlsZE5vZGVzIGF0IGVhY2ggbGV2ZWwuXG4gICAgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRyZWU6IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldLFxuICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlLnBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IG92ZXJyaWRpbmcgb2YgdXJsIGZvciBwYXJhbGxlbCByb3V0ZXNcbiAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgIH1cbiAgICB9LCBjaGlsZE5vZGUuc3ViVHJlZURhdGEpO1xuICAgIC8vIEVuc3VyZSByb290IGxheW91dCBpcyBub3Qgd3JhcHBlZCBpbiBhIGRpdiBhcyB0aGUgcm9vdCBsYXlvdXQgcmVuZGVycyBgPGh0bWw+YFxuICAgIHJldHVybiByb290TGF5b3V0SW5jbHVkZWQgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICByZWY6IGZvY3VzQW5kU2Nyb2xsRWxlbWVudFJlZixcbiAgICAgICAgXCJkYXRhLW5leHRqcy1zY3JvbGwtZm9jdXMtYm91bmRhcnlcIjogJydcbiAgICB9LCBzdWJ0cmVlKSA6IHN1YnRyZWU7XG59XG4vKipcbiAqIFJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgd2l0aCB0aGUgcHJvdmlkZWQgXCJsb2FkaW5nXCIgcHJvcGVydHkgYXMgdGhlIGZhbGxiYWNrLlxuICogSWYgbm8gbG9hZGluZyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBpdCByZW5kZXJzIHRoZSBjaGlsZHJlbiB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gKi8gZnVuY3Rpb24gTG9hZGluZ0JvdW5kYXJ5KHsgY2hpbGRyZW4gLCBsb2FkaW5nICwgbG9hZGluZ1N0eWxlcyAsIGhhc0xvYWRpbmcgIH0pIHtcbiAgICBpZiAoaGFzTG9hZGluZykge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN1c3BlbnNlLCB7XG4gICAgICAgICAgICBmYWxsYmFjazogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBsb2FkaW5nU3R5bGVzLCBsb2FkaW5nKVxuICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIEhhbmRsZVJlZGlyZWN0KHsgcmVkaXJlY3QgIH0pIHtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24pLnVzZVJvdXRlcigpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICByb3V0ZXIucmVwbGFjZShyZWRpcmVjdCwge30pO1xuICAgIH0sIFtcbiAgICAgICAgcmVkaXJlY3QsXG4gICAgICAgIHJvdXRlclxuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuY2xhc3MgUmVkaXJlY3RFcnJvckJvdW5kYXJ5IGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGlmICgocmVmID0gZXJyb3IuZGlnZXN0KSA9PSBudWxsID8gdm9pZCAwIDogcmVmLnN0YXJ0c1dpdGgoJ05FWFRfUkVESVJFQ1QnKSkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZXJyb3IuZGlnZXN0LnNwbGl0KCc7JylbMV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiB1cmxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciByZWRpcmVjdFxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCByZWRpcmVjdCA9IHRoaXMuc3RhdGUucmVkaXJlY3Q7XG4gICAgICAgIGlmIChyZWRpcmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIYW5kbGVSZWRpcmVjdCwge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiByZWRpcmVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcmVkaXJlY3Q6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBSZWRpcmVjdEJvdW5kYXJ5KHsgY2hpbGRyZW4gIH0pIHtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24pLnVzZVJvdXRlcigpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVkaXJlY3RFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIHJvdXRlcjogcm91dGVyXG4gICAgfSwgY2hpbGRyZW4pO1xufVxuY2xhc3MgTm90Rm91bmRFcnJvckJvdW5kYXJ5IGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5kaWdlc3QgPT09ICdORVhUX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm90Rm91bmRUcmlnZ2VyZWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubm90Rm91bmRUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwicm9ib3RzXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJub2luZGV4XCJcbiAgICAgICAgICAgIH0pLCB0aGlzLnByb3BzLm5vdEZvdW5kU3R5bGVzLCB0aGlzLnByb3BzLm5vdEZvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBub3RGb3VuZFRyaWdnZXJlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBOb3RGb3VuZEJvdW5kYXJ5KHsgbm90Rm91bmQgLCBub3RGb3VuZFN0eWxlcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgcmV0dXJuIG5vdEZvdW5kID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE5vdEZvdW5kRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBub3RGb3VuZDogbm90Rm91bmQsXG4gICAgICAgIG5vdEZvdW5kU3R5bGVzOiBub3RGb3VuZFN0eWxlc1xuICAgIH0sIGNoaWxkcmVuKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXlvdXQtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk91dGVyTGF5b3V0Um91dGVyIiwiSW5uZXJMYXlvdXRSb3V0ZXIiLCJfZXh0ZW5kcyIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlYWN0IiwiX2FwcFJvdXRlckNvbnRleHQiLCJfYXBwUm91dGVyIiwiX2luZmluaXRlUHJvbWlzZSIsIl9lcnJvckJvdW5kYXJ5IiwiX21hdGNoU2VnbWVudHMiLCJfbmF2aWdhdGlvbiIsInBhcmFsbGVsUm91dGVyS2V5Iiwic2VnbWVudFBhdGgiLCJjaGlsZFByb3AiLCJlcnJvciIsImVycm9yU3R5bGVzIiwidGVtcGxhdGVTdHlsZXMiLCJsb2FkaW5nIiwibG9hZGluZ1N0eWxlcyIsImhhc0xvYWRpbmciLCJ0ZW1wbGF0ZSIsIm5vdEZvdW5kIiwibm90Rm91bmRTdHlsZXMiLCJyb290TGF5b3V0SW5jbHVkZWQiLCJjb250ZXh0IiwidXNlQ29udGV4dCIsIkxheW91dFJvdXRlckNvbnRleHQiLCJFcnJvciIsImNoaWxkTm9kZXMiLCJ0cmVlIiwidXJsIiwiY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyIiwiZ2V0Iiwic2V0IiwiTWFwIiwidHJlZVNlZ21lbnQiLCJjaGlsZFByb3BTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5Iiwic2VnbWVudCIsImN1cnJlbnRDaGlsZFNlZ21lbnQiLCJwcmVzZXJ2ZWRTZWdtZW50cyIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsIm1hcCIsInByZXNlcnZlZFNlZ21lbnQiLCJUZW1wbGF0ZUNvbnRleHQiLCJQcm92aWRlciIsImtleSIsIkVycm9yQm91bmRhcnkiLCJlcnJvckNvbXBvbmVudCIsIkxvYWRpbmdCb3VuZGFyeSIsIk5vdEZvdW5kQm91bmRhcnkiLCJSZWRpcmVjdEJvdW5kYXJ5IiwicGF0aCIsImlzQWN0aXZlIiwid2Fsa0FkZFJlZmV0Y2giLCJzZWdtZW50UGF0aFRvV2FsayIsInRyZWVUb1JlY3JlYXRlIiwicGFyYWxsZWxSb3V0ZUtleSIsImlzTGFzdCIsImxlbmd0aCIsIm1hdGNoU2VnbWVudCIsImhhc093blByb3BlcnR5Iiwic3ViVHJlZSIsInVuZGVmaW5lZCIsInNsaWNlIiwidG9wT2ZFbGVtZW50SW5WaWV3cG9ydCIsImVsZW1lbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsImNoYW5nZUJ5U2VydmVyUmVzcG9uc2UiLCJmdWxsVHJlZSIsImZvY3VzQW5kU2Nyb2xsUmVmIiwiZm9jdXNBbmRTY3JvbGxFbGVtZW50UmVmIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiYXBwbHkiLCJjdXJyZW50IiwiZm9jdXMiLCJodG1sRWxlbWVudCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZXhpc3RpbmciLCJzdHlsZSIsInNjcm9sbEJlaGF2aW9yIiwic2Nyb2xsSW50b1ZpZXciLCJjaGlsZE5vZGUiLCJzdGF0dXMiLCJDYWNoZVN0YXRlcyIsIkxBWllfSU5JVElBTElaRUQiLCJSRUFEWSIsInN1YlRyZWVEYXRhIiwiZGF0YSIsInBhcmFsbGVsUm91dGVzIiwicmVmZXRjaFRyZWUiLCJEQVRBX0ZFVENIIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwiaGVhZCIsInVzZSIsImZsaWdodERhdGEiLCJvdmVycmlkZUNhbm9uaWNhbFVybCIsIndpbmRvdyIsImhyZWYiLCJzZXRUaW1lb3V0Iiwic3RhcnRUcmFuc2l0aW9uIiwiY3JlYXRlSW5maW5pdGVQcm9taXNlIiwic3VidHJlZSIsInJlZiIsImNoaWxkcmVuIiwiU3VzcGVuc2UiLCJmYWxsYmFjayIsIkhhbmRsZVJlZGlyZWN0IiwicmVkaXJlY3QiLCJyb3V0ZXIiLCJ1c2VSb3V0ZXIiLCJyZXBsYWNlIiwiUmVkaXJlY3RFcnJvckJvdW5kYXJ5IiwicHJvcHMiLCJzdGF0ZSIsImRpZ2VzdCIsInN0YXJ0c1dpdGgiLCJzcGxpdCIsIkNvbXBvbmVudCIsIk5vdEZvdW5kRXJyb3JCb3VuZGFyeSIsIm5vdEZvdW5kVHJpZ2dlcmVkIiwibmFtZSIsImNvbnRlbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/match-segments.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/match-segments.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.matchSegment = void 0;\n\nvar matchSegment = function matchSegment(existingSegment, segment) {\n  // Common case: segment is just a string\n  if (typeof existingSegment === 'string' && typeof segment === 'string') {\n    return existingSegment === segment;\n  } // Dynamic parameter case: segment is an array with param/value. Both param and value are compared.\n\n\n  if (Array.isArray(existingSegment) && Array.isArray(segment)) {\n    return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\n  }\n\n  return false;\n};\n\nexports.matchSegment = matchSegment;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL21hdGNoLXNlZ21lbnRzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxvQkFBQSxHQUF1QixLQUFLLENBQTVCOztBQUNBLElBQU1FLFlBQVksR0FBRyxTQUFmQSxZQUFlLENBQUNDLGVBQUQsRUFBa0JDLE9BQWxCLEVBQTRCO0VBQzdDO0VBQ0EsSUFBSSxPQUFPRCxlQUFQLEtBQTJCLFFBQTNCLElBQXVDLE9BQU9DLE9BQVAsS0FBbUIsUUFBOUQsRUFBd0U7SUFDcEUsT0FBT0QsZUFBZSxLQUFLQyxPQUEzQjtFQUNILENBSjRDLENBSzdDOzs7RUFDQSxJQUFJQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0gsZUFBZCxLQUFrQ0UsS0FBSyxDQUFDQyxPQUFOLENBQWNGLE9BQWQsQ0FBdEMsRUFBOEQ7SUFDMUQsT0FBT0QsZUFBZSxDQUFDLENBQUQsQ0FBZixLQUF1QkMsT0FBTyxDQUFDLENBQUQsQ0FBOUIsSUFBcUNELGVBQWUsQ0FBQyxDQUFELENBQWYsS0FBdUJDLE9BQU8sQ0FBQyxDQUFELENBQTFFO0VBQ0g7O0VBQ0QsT0FBTyxLQUFQO0FBQ0gsQ0FWRDs7QUFXQUosb0JBQUEsR0FBdUJFLFlBQXZCOztBQUVBLElBQUksQ0FBQyxPQUFPRixPQUFPLFdBQWQsS0FBMkIsVUFBM0IsSUFBMEMsT0FBT0EsT0FBTyxXQUFkLEtBQTJCLFFBQTNCLElBQXVDQSxPQUFPLFdBQVAsS0FBb0IsSUFBdEcsS0FBZ0gsT0FBT0EsT0FBTyxXQUFQLENBQWdCTyxVQUF2QixLQUFzQyxXQUExSixFQUF1SztFQUNyS1QsTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUFPLFdBQTdCLEVBQXVDLFlBQXZDLEVBQXFEO0lBQUVDLEtBQUssRUFBRTtFQUFULENBQXJEO0VBQ0FILE1BQU0sQ0FBQ1UsTUFBUCxDQUFjUixPQUFPLFdBQXJCLEVBQStCQSxPQUEvQjtFQUNBUyxNQUFNLENBQUNULE9BQVAsR0FBaUJBLE9BQU8sV0FBeEI7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL21hdGNoLXNlZ21lbnRzLmpzP2JjYjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1hdGNoU2VnbWVudCA9IHZvaWQgMDtcbmNvbnN0IG1hdGNoU2VnbWVudCA9IChleGlzdGluZ1NlZ21lbnQsIHNlZ21lbnQpPT57XG4gICAgLy8gQ29tbW9uIGNhc2U6IHNlZ21lbnQgaXMganVzdCBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmdTZWdtZW50ID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc2VnbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VnbWVudCA9PT0gc2VnbWVudDtcbiAgICB9XG4gICAgLy8gRHluYW1pYyBwYXJhbWV0ZXIgY2FzZTogc2VnbWVudCBpcyBhbiBhcnJheSB3aXRoIHBhcmFtL3ZhbHVlLiBCb3RoIHBhcmFtIGFuZCB2YWx1ZSBhcmUgY29tcGFyZWQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXhpc3RpbmdTZWdtZW50KSAmJiBBcnJheS5pc0FycmF5KHNlZ21lbnQpKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1NlZ21lbnRbMF0gPT09IHNlZ21lbnRbMF0gJiYgZXhpc3RpbmdTZWdtZW50WzFdID09PSBzZWdtZW50WzFdO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZXhwb3J0cy5tYXRjaFNlZ21lbnQgPSBtYXRjaFNlZ21lbnQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGNoLXNlZ21lbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hdGNoU2VnbWVudCIsImV4aXN0aW5nU2VnbWVudCIsInNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/match-segments.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/reducer.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/client/components/reducer.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\n\nvar _toConsumableArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray.js\");\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createHrefFromUrl = createHrefFromUrl;\nexports.reducer = exports.ACTION_PREFETCH = exports.ACTION_SERVER_PATCH = exports.ACTION_RESTORE = exports.ACTION_NAVIGATE = exports.ACTION_REFRESH = void 0;\n\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\n\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\n\nvar _matchSegments = __webpack_require__(/*! ./match-segments */ \"./node_modules/next/dist/client/components/match-segments.js\");\n\nvar _appRouter = __webpack_require__(/*! ./app-router */ \"./node_modules/next/dist/client/components/app-router.js\");\n/**\n * Create data fetching record for Promise.\n */\n// TODO-APP: change `any` to type inference.\n\n\nfunction createRecordFromThenable(thenable) {\n  thenable.status = 'pending';\n  thenable.then(function (value) {\n    if (thenable.status === 'pending') {\n      thenable.status = 'fulfilled';\n      thenable.value = value;\n    }\n  }, function (err) {\n    if (thenable.status === 'pending') {\n      thenable.status = 'rejected';\n      thenable.value = err;\n    }\n  });\n  return thenable;\n}\n/**\n * Read record value or throw Promise if it's not resolved yet.\n */\n\n\nfunction readRecordValue(thenable) {\n  // @ts-expect-error TODO: fix type\n  if (thenable.status === 'fulfilled') {\n    // @ts-expect-error TODO: fix type\n    return thenable.value;\n  } else {\n    throw thenable;\n  }\n}\n\nfunction createHrefFromUrl(url) {\n  return url.pathname + url.search + url.hash;\n}\n/**\n * Invalidate cache one level down from the router state.\n */\n// TODO-APP: Verify if this needs to be recursive.\n\n\nfunction invalidateCacheByRouterState(newCache, existingCache, routerState) {\n  // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n  for (var key in routerState[1]) {\n    var segmentForParallelRoute = routerState[1][key][0];\n    var cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n    var existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n\n    if (existingParallelRoutesCacheNode) {\n      var parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n      parallelRouteCacheNode[\"delete\"](cacheKey);\n      newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n    }\n  }\n}\n\nfunction fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, head) {\n  var isLastSegment = Object.keys(routerState[1]).length === 0;\n\n  if (isLastSegment) {\n    newCache.head = head;\n    return;\n  } // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n\n\n  for (var key in routerState[1]) {\n    var parallelRouteState = routerState[1][key];\n    var segmentForParallelRoute = parallelRouteState[0];\n    var cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n\n    if (existingCache) {\n      var existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n\n      if (existingParallelRoutesCacheNode) {\n        var parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n        parallelRouteCacheNode[\"delete\"](cacheKey);\n        var _newCacheNode = {\n          status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n          data: null,\n          subTreeData: null,\n          parallelRoutes: new Map()\n        };\n        parallelRouteCacheNode.set(cacheKey, _newCacheNode);\n        fillLazyItemsTillLeafWithHead(_newCacheNode, undefined, parallelRouteState, head);\n        newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n        continue;\n      }\n    }\n\n    var newCacheNode = {\n      status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n      data: null,\n      subTreeData: null,\n      parallelRoutes: new Map()\n    };\n    newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]));\n    fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, head);\n  }\n}\n/**\n * Fill cache with subTreeData based on flightDataPath\n */\n\n\nfunction fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath) {\n  var isLastEntry = flightDataPath.length <= 5;\n\n  var _flightDataPath = _slicedToArray(flightDataPath, 2),\n      parallelRouteKey = _flightDataPath[0],\n      segment = _flightDataPath[1];\n\n  var segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n  var existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return;\n  }\n\n  var childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap);\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n  }\n\n  var existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n  var childCacheNode = childSegmentMap.get(segmentForCache);\n\n  if (isLastEntry) {\n    if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n      childCacheNode = {\n        status: _appRouterContext.CacheStates.READY,\n        data: null,\n        subTreeData: flightDataPath[3],\n        // Ensure segments other than the one we got data for are preserved.\n        parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map()\n      };\n\n      if (existingChildCacheNode) {\n        invalidateCacheByRouterState(childCacheNode, existingChildCacheNode, flightDataPath[2]);\n      }\n\n      fillLazyItemsTillLeafWithHead(childCacheNode, existingChildCacheNode, flightDataPath[2], flightDataPath[4]);\n      childSegmentMap.set(segmentForCache, childCacheNode);\n    }\n\n    return;\n  }\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return;\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      status: childCacheNode.status,\n      data: childCacheNode.data,\n      subTreeData: childCacheNode.subTreeData,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes)\n    };\n    childSegmentMap.set(segmentForCache, childCacheNode);\n  }\n\n  fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2));\n}\n/**\n * Fill cache up to the end of the flightSegmentPath, invalidating anything below it.\n */\n\n\nfunction invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {\n  var isLastEntry = flightSegmentPath.length <= 2;\n\n  var _flightSegmentPath = _slicedToArray(flightSegmentPath, 2),\n      parallelRouteKey = _flightSegmentPath[0],\n      segment = _flightSegmentPath[1];\n\n  var segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n  var existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return;\n  }\n\n  var childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap);\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n  } // In case of last entry don't copy further down.\n\n\n  if (isLastEntry) {\n    childSegmentMap[\"delete\"](segmentForCache);\n    return;\n  }\n\n  var existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n  var childCacheNode = childSegmentMap.get(segmentForCache);\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return;\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      status: childCacheNode.status,\n      data: childCacheNode.data,\n      subTreeData: childCacheNode.subTreeData,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes)\n    };\n    childSegmentMap.set(segmentForCache, childCacheNode);\n  }\n\n  invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));\n}\n/**\n * Fill cache with subTreeData based on flightDataPath that was prefetched\n * This operation is append-only to the existing cache.\n */\n\n\nfunction fillCacheWithPrefetchedSubTreeData(existingCache, flightDataPath) {\n  var isLastEntry = flightDataPath.length <= 5;\n\n  var _flightDataPath2 = _slicedToArray(flightDataPath, 2),\n      parallelRouteKey = _flightDataPath2[0],\n      segment = _flightDataPath2[1];\n\n  var segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n  var existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    return;\n  }\n\n  var existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n\n  if (isLastEntry) {\n    if (!existingChildCacheNode) {\n      var childCacheNode = {\n        status: _appRouterContext.CacheStates.READY,\n        data: null,\n        subTreeData: flightDataPath[3],\n        parallelRoutes: new Map()\n      };\n      fillLazyItemsTillLeafWithHead(childCacheNode, existingChildCacheNode, flightDataPath[2], flightDataPath[4]);\n      existingChildSegmentMap.set(segmentForCache, childCacheNode);\n    }\n\n    return;\n  }\n\n  if (!existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    return;\n  }\n\n  fillCacheWithPrefetchedSubTreeData(existingChildCacheNode, flightDataPath.slice(2));\n}\n/**\n * Kick off fetch based on the common layout between two routes. Fill cache with data property holding the in-progress fetch.\n */\n\n\nfunction fillCacheWithDataProperty(newCache, existingCache, segments, fetchResponse) {\n  var isLastEntry = segments.length === 1;\n  var parallelRouteKey = 'children';\n\n  var _segments = _slicedToArray(segments, 1),\n      segment = _segments[0];\n\n  var existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return {\n      bailOptimistic: true\n    };\n  }\n\n  var childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap);\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n  }\n\n  var existingChildCacheNode = existingChildSegmentMap.get(segment);\n  var childCacheNode = childSegmentMap.get(segment); // In case of last segment start off the fetch at this level and don't copy further down.\n\n  if (isLastEntry) {\n    if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n      childSegmentMap.set(segment, {\n        status: _appRouterContext.CacheStates.DATA_FETCH,\n        data: fetchResponse(),\n        subTreeData: null,\n        parallelRoutes: new Map()\n      });\n    }\n\n    return;\n  }\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Start fetch in the place where the existing cache doesn't have the data yet.\n    if (!childCacheNode) {\n      childSegmentMap.set(segment, {\n        status: _appRouterContext.CacheStates.DATA_FETCH,\n        data: fetchResponse(),\n        subTreeData: null,\n        parallelRoutes: new Map()\n      });\n    }\n\n    return;\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      status: childCacheNode.status,\n      data: childCacheNode.data,\n      subTreeData: childCacheNode.subTreeData,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes)\n    };\n    childSegmentMap.set(segment, childCacheNode);\n  }\n\n  return fillCacheWithDataProperty(childCacheNode, existingChildCacheNode, segments.slice(1), fetchResponse);\n}\n/**\n * Create optimistic version of router state based on the existing router state and segments.\n * This is used to allow rendering layout-routers up till the point where data is missing.\n */\n\n\nfunction createOptimisticTree(segments, flightRouterState, _isFirstSegment, parentRefetch, _href) {\n  var _ref = flightRouterState || [null, {}],\n      _ref2 = _slicedToArray(_ref, 2),\n      existingSegment = _ref2[0],\n      existingParallelRoutes = _ref2[1];\n\n  var segment = segments[0];\n  var isLastSegment = segments.length === 1;\n  var segmentMatches = existingSegment !== null && (0, _matchSegments).matchSegment(existingSegment, segment);\n  var shouldRefetchThisLevel = !flightRouterState || !segmentMatches;\n  var parallelRoutes = {};\n\n  if (existingSegment !== null && segmentMatches) {\n    parallelRoutes = existingParallelRoutes;\n  }\n\n  var childTree;\n\n  if (!isLastSegment) {\n    var childItem = createOptimisticTree(segments.slice(1), parallelRoutes ? parallelRoutes.children : null, false, parentRefetch || shouldRefetchThisLevel);\n    childTree = childItem;\n  }\n\n  var result = [segment, _extends({}, parallelRoutes, childTree ? {\n    children: childTree\n  } : {})];\n\n  if (!parentRefetch && shouldRefetchThisLevel) {\n    result[3] = 'refetch';\n  } // TODO-APP: Revisit\n  // Add url into the tree\n  // if (isFirstSegment) {\n  //   result[2] = href\n  // }\n\n\n  return result;\n}\n/**\n * Apply the router state from the Flight response. Creates a new router state tree.\n */\n\n\nfunction applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch) {\n  var _flightRouterState = _slicedToArray(flightRouterState, 5),\n      segment = _flightRouterState[0],\n      parallelRoutes = _flightRouterState[1],\n      isRootLayout = _flightRouterState[4]; // Root refresh\n\n\n  if (flightSegmentPath.length === 1) {\n    var _tree = _toConsumableArray(treePatch); // TODO-APP: revisit\n    // if (url) {\n    //   tree[2] = url\n    // }\n\n\n    return _tree;\n  }\n\n  var _flightSegmentPath2 = _slicedToArray(flightSegmentPath, 2),\n      currentSegment = _flightSegmentPath2[0],\n      parallelRouteKey = _flightSegmentPath2[1]; // Tree path returned from the server should always match up with the current tree in the browser\n\n\n  if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n    return null;\n  }\n\n  var lastSegment = flightSegmentPath.length === 2;\n  var parallelRoutePatch;\n\n  if (lastSegment) {\n    parallelRoutePatch = treePatch;\n  } else {\n    parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n\n    if (parallelRoutePatch === null) {\n      return null;\n    }\n  }\n\n  var tree = [flightSegmentPath[0], _extends({}, parallelRoutes, _defineProperty({}, parallelRouteKey, parallelRoutePatch))]; // Current segment is the root layout\n\n  if (isRootLayout) {\n    tree[4] = true;\n  } // TODO-APP: Revisit\n  // if (url) {\n  //   tree[2] = url\n  // }\n\n\n  return tree;\n}\n\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState, treePatch) {\n  var _flightRouterState2 = _slicedToArray(flightRouterState, 2),\n      segment = _flightRouterState2[0],\n      parallelRoutes = _flightRouterState2[1]; // TODO-APP: Check if `as` can be replaced.\n\n\n  var _flightSegmentPath3 = _slicedToArray(flightSegmentPath, 2),\n      currentSegment = _flightSegmentPath3[0],\n      parallelRouteKey = _flightSegmentPath3[1]; // Check if current segment matches the existing segment.\n\n\n  if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n    // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n    if (Array.isArray(currentSegment)) {\n      return true;\n    } // If the existing segment did not match soft navigation is triggered.\n\n\n    return false;\n  }\n\n  var lastSegment = flightSegmentPath.length <= 2;\n\n  if (lastSegment) {\n    return false;\n  }\n\n  return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n}\n\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n  // Compare segments\n  var currentTreeSegment = currentTree[0];\n  var nextTreeSegment = nextTree[0]; // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n      return true;\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true;\n  } // Current tree root layout found\n\n\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4];\n  } // Current tree  didn't have its root layout here, must have changed.\n\n\n  if (nextTree[4]) {\n    return true;\n  } // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n\n\n  var currentTreeChild = Object.values(currentTree[1])[0];\n  var nextTreeChild = Object.values(nextTree[1])[0];\n  if (!currentTreeChild || !nextTreeChild) return true;\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\n\nvar ACTION_REFRESH = 'refresh';\nexports.ACTION_REFRESH = ACTION_REFRESH;\nvar ACTION_NAVIGATE = 'navigate';\nexports.ACTION_NAVIGATE = ACTION_NAVIGATE;\nvar ACTION_RESTORE = 'restore';\nexports.ACTION_RESTORE = ACTION_RESTORE;\nvar ACTION_SERVER_PATCH = 'server-patch';\nexports.ACTION_SERVER_PATCH = ACTION_SERVER_PATCH;\nvar ACTION_PREFETCH = 'prefetch';\nexports.ACTION_PREFETCH = ACTION_PREFETCH;\n/**\n * Reducer that handles the app-router state updates.\n */\n\nfunction clientReducer(state, action) {\n  switch (action.type) {\n    case ACTION_NAVIGATE:\n      {\n        var url = action.url,\n            navigateType = action.navigateType,\n            cache = action.cache,\n            mutable = action.mutable,\n            forceOptimisticNavigation = action.forceOptimisticNavigation;\n        var pathname = url.pathname,\n            search = url.search;\n        var href = createHrefFromUrl(url);\n        var pendingPush = navigateType === 'push';\n        var isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);\n\n        if (mutable.mpaNavigation && isForCurrentTree) {\n          return {\n            // Set href.\n            canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : href,\n            // TODO-APP: verify mpaNavigation not being set is correct here.\n            pushRef: {\n              pendingPush: pendingPush,\n              mpaNavigation: mutable.mpaNavigation\n            },\n            // All navigation requires scroll and focus management to trigger.\n            focusAndScrollRef: {\n              apply: false\n            },\n            // Apply cache.\n            cache: state.cache,\n            prefetchCache: state.prefetchCache,\n            // Apply patched router state.\n            tree: state.tree\n          };\n        } // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n\n\n        if (mutable.patchedTree && isForCurrentTree) {\n          return {\n            // Set href.\n            canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : href,\n            // TODO-APP: verify mpaNavigation not being set is correct here.\n            pushRef: {\n              pendingPush: pendingPush,\n              mpaNavigation: false\n            },\n            // All navigation requires scroll and focus management to trigger.\n            focusAndScrollRef: {\n              apply: true\n            },\n            // Apply cache.\n            cache: mutable.useExistingCache ? state.cache : cache,\n            prefetchCache: state.prefetchCache,\n            // Apply patched router state.\n            tree: mutable.patchedTree\n          };\n        }\n\n        var prefetchValues = state.prefetchCache.get(href);\n\n        if (prefetchValues) {\n          // The one before last item is the router state tree patch\n          var _flightSegmentPath4 = prefetchValues.flightSegmentPath,\n              _newTree = prefetchValues.tree,\n              _canonicalUrlOverride = prefetchValues.canonicalUrlOverride;\n\n          if (_newTree !== null) {\n            mutable.previousTree = state.tree;\n            mutable.patchedTree = _newTree;\n            mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, _newTree);\n            var hardNavigate = // TODO-APP: Revisit if this is correct.\n            search !== location.search || shouldHardNavigate( // TODO-APP: remove ''\n            [''].concat(_toConsumableArray(_flightSegmentPath4)), state.tree, _newTree);\n\n            if (hardNavigate) {\n              // TODO-APP: segments.slice(1) strips '', we can get rid of '' altogether.\n              // Copy subTreeData for the root node of the cache.\n              cache.subTreeData = state.cache.subTreeData;\n              invalidateCacheBelowFlightSegmentPath(cache, state.cache, _flightSegmentPath4);\n            } else {\n              mutable.useExistingCache = true;\n            }\n\n            var _canonicalUrlOverrideHref = _canonicalUrlOverride ? createHrefFromUrl(_canonicalUrlOverride) : undefined;\n\n            if (_canonicalUrlOverrideHref) {\n              mutable.canonicalUrlOverride = _canonicalUrlOverrideHref;\n            }\n\n            return {\n              // Set href.\n              canonicalUrl: _canonicalUrlOverrideHref ? _canonicalUrlOverrideHref : href,\n              // Set pendingPush.\n              pushRef: {\n                pendingPush: pendingPush,\n                mpaNavigation: false\n              },\n              // All navigation requires scroll and focus management to trigger.\n              focusAndScrollRef: {\n                apply: true\n              },\n              // Apply patched cache.\n              cache: mutable.useExistingCache ? state.cache : cache,\n              prefetchCache: state.prefetchCache,\n              // Apply patched tree.\n              tree: _newTree\n            };\n          }\n        } // When doing a hard push there can be two cases: with optimistic tree and without\n        // The with optimistic tree case only happens when the layouts have a loading state (loading.js)\n        // The without optimistic tree case happens when there is no loading state, in that case we suspend in this reducer\n        // forceOptimisticNavigation is used for links that have `prefetch={false}`.\n\n\n        if (forceOptimisticNavigation) {\n          var segments = pathname.split('/'); // TODO-APP: figure out something better for index pages\n\n          segments.push(''); // Optimistic tree case.\n          // If the optimistic tree is deeper than the current state leave that deeper part out of the fetch\n\n          var optimisticTree = createOptimisticTree(segments, state.tree, true, false, href); // Copy subTreeData for the root node of the cache.\n\n          cache.subTreeData = state.cache.subTreeData; // Copy existing cache nodes as far as possible and fill in `data` property with the started data fetch.\n          // The `data` property is used to suspend in layout-router during render if it hasn't resolved yet by the time it renders.\n\n          var res = fillCacheWithDataProperty(cache, state.cache, // TODO-APP: segments.slice(1) strips '', we can get rid of '' altogether.\n          segments.slice(1), function () {\n            return (0, _appRouter).fetchServerResponse(url, optimisticTree);\n          }); // If optimistic fetch couldn't happen it falls back to the non-optimistic case.\n\n          if (!(res == null ? void 0 : res.bailOptimistic)) {\n            mutable.previousTree = state.tree;\n            mutable.patchedTree = optimisticTree;\n            mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, optimisticTree);\n            return {\n              // Set href.\n              canonicalUrl: href,\n              // Set pendingPush.\n              pushRef: {\n                pendingPush: pendingPush,\n                mpaNavigation: false\n              },\n              // All navigation requires scroll and focus management to trigger.\n              focusAndScrollRef: {\n                apply: true\n              },\n              // Apply patched cache.\n              cache: cache,\n              prefetchCache: state.prefetchCache,\n              // Apply optimistic tree.\n              tree: optimisticTree\n            };\n          }\n        } // Below is the not-optimistic case. Data is fetched at the root and suspended there without a suspense boundary.\n        // If no in-flight fetch at the top, start it.\n\n\n        if (!cache.data) {\n          cache.data = createRecordFromThenable((0, _appRouter).fetchServerResponse(url, state.tree));\n        } // Unwrap cache data with `use` to suspend here (in the reducer) until the fetch resolves.\n\n\n        var _readRecordValue = readRecordValue(cache.data),\n            _readRecordValue2 = _slicedToArray(_readRecordValue, 2),\n            flightData = _readRecordValue2[0],\n            canonicalUrlOverride = _readRecordValue2[1]; // Handle case when navigating to page in `pages` from `app`\n\n\n        if (typeof flightData === 'string') {\n          return {\n            canonicalUrl: flightData,\n            // Enable mpaNavigation\n            pushRef: {\n              pendingPush: true,\n              mpaNavigation: true\n            },\n            // Don't apply scroll and focus management.\n            focusAndScrollRef: {\n              apply: false\n            },\n            cache: state.cache,\n            prefetchCache: state.prefetchCache,\n            tree: state.tree\n          };\n        } // Remove cache.data as it has been resolved at this point.\n\n\n        cache.data = null; // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n\n        var flightDataPath = flightData[0]; // The one before last item is the router state tree patch\n\n        var _flightDataPath$slice = flightDataPath.slice(-3),\n            _flightDataPath$slice2 = _slicedToArray(_flightDataPath$slice, 3),\n            treePatch = _flightDataPath$slice2[0],\n            subTreeData = _flightDataPath$slice2[1],\n            head = _flightDataPath$slice2[2]; // Path without the last segment, router state, and the subTreeData\n\n\n        var flightSegmentPath = flightDataPath.slice(0, -4); // Create new tree based on the flightSegmentPath and router state patch\n\n        var newTree = applyRouterStatePatchToTree( // TODO-APP: remove ''\n        [''].concat(_toConsumableArray(flightSegmentPath)), state.tree, treePatch);\n\n        if (newTree === null) {\n          throw new Error('SEGMENT MISMATCH');\n        }\n\n        var canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;\n\n        if (canonicalUrlOverrideHref) {\n          mutable.canonicalUrlOverride = canonicalUrlOverrideHref;\n        }\n\n        mutable.previousTree = state.tree;\n        mutable.patchedTree = newTree;\n        mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree);\n\n        if (flightDataPath.length === 3) {\n          cache.subTreeData = subTreeData;\n          fillLazyItemsTillLeafWithHead(cache, state.cache, treePatch, head);\n        } else {\n          // Copy subTreeData for the root node of the cache.\n          cache.subTreeData = state.cache.subTreeData; // Create a copy of the existing cache with the subTreeData applied.\n\n          fillCacheWithNewSubTreeData(cache, state.cache, flightDataPath);\n        }\n\n        return {\n          // Set href.\n          canonicalUrl: canonicalUrlOverrideHref ? canonicalUrlOverrideHref : href,\n          // Set pendingPush.\n          pushRef: {\n            pendingPush: pendingPush,\n            mpaNavigation: false\n          },\n          // All navigation requires scroll and focus management to trigger.\n          focusAndScrollRef: {\n            apply: true\n          },\n          // Apply patched cache.\n          cache: cache,\n          prefetchCache: state.prefetchCache,\n          // Apply patched tree.\n          tree: newTree\n        };\n      }\n\n    case ACTION_SERVER_PATCH:\n      {\n        var _flightData = action.flightData,\n            previousTree = action.previousTree,\n            overrideCanonicalUrl = action.overrideCanonicalUrl,\n            _cache = action.cache,\n            _mutable = action.mutable; // When a fetch is slow to resolve it could be that you navigated away while the request was happening or before the reducer runs.\n        // In that case opt-out of applying the patch given that the data could be stale.\n\n        if (JSON.stringify(previousTree) !== JSON.stringify(state.tree)) {\n          // TODO-APP: Handle tree mismatch\n          console.log('TREE MISMATCH'); // Keep everything as-is.\n\n          return state;\n        }\n\n        if (_mutable.mpaNavigation) {\n          return {\n            // Set href.\n            canonicalUrl: _mutable.canonicalUrlOverride ? _mutable.canonicalUrlOverride : state.canonicalUrl,\n            // TODO-APP: verify mpaNavigation not being set is correct here.\n            pushRef: {\n              pendingPush: true,\n              mpaNavigation: _mutable.mpaNavigation\n            },\n            // All navigation requires scroll and focus management to trigger.\n            focusAndScrollRef: {\n              apply: false\n            },\n            // Apply cache.\n            cache: state.cache,\n            prefetchCache: state.prefetchCache,\n            // Apply patched router state.\n            tree: state.tree\n          };\n        } // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n\n\n        if (_mutable.patchedTree) {\n          return {\n            // Keep href as it was set during navigate / restore\n            canonicalUrl: _mutable.canonicalUrlOverride ? _mutable.canonicalUrlOverride : state.canonicalUrl,\n            // Keep pushRef as server-patch only causes cache/tree update.\n            pushRef: state.pushRef,\n            // Keep focusAndScrollRef as server-patch only causes cache/tree update.\n            focusAndScrollRef: state.focusAndScrollRef,\n            // Apply patched router state\n            tree: _mutable.patchedTree,\n            prefetchCache: state.prefetchCache,\n            // Apply patched cache\n            cache: _cache\n          };\n        } // Handle case when navigating to page in `pages` from `app`\n\n\n        if (typeof _flightData === 'string') {\n          return {\n            // Set href.\n            canonicalUrl: _flightData,\n            // Enable mpaNavigation as this is a navigation that the app-router shouldn't handle.\n            pushRef: {\n              pendingPush: true,\n              mpaNavigation: true\n            },\n            // Don't apply scroll and focus management.\n            focusAndScrollRef: {\n              apply: false\n            },\n            // Other state is kept as-is.\n            cache: state.cache,\n            prefetchCache: state.prefetchCache,\n            tree: state.tree\n          };\n        } // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n\n\n        var _flightDataPath3 = _flightData[0]; // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet\n\n        var _flightSegmentPath5 = _flightDataPath3.slice(0, -4);\n\n        var _flightDataPath3$slic = _flightDataPath3.slice(-3),\n            _flightDataPath3$slic2 = _slicedToArray(_flightDataPath3$slic, 3),\n            _treePatch = _flightDataPath3$slic2[0],\n            _subTreeData = _flightDataPath3$slic2[1],\n            _head = _flightDataPath3$slic2[2];\n\n        var _newTree2 = applyRouterStatePatchToTree( // TODO-APP: remove ''\n        [''].concat(_toConsumableArray(_flightSegmentPath5)), state.tree, _treePatch);\n\n        if (_newTree2 === null) {\n          throw new Error('SEGMENT MISMATCH');\n        }\n\n        var _canonicalUrlOverrideHref2 = overrideCanonicalUrl ? createHrefFromUrl(overrideCanonicalUrl) : undefined;\n\n        if (_canonicalUrlOverrideHref2) {\n          _mutable.canonicalUrlOverride = _canonicalUrlOverrideHref2;\n        }\n\n        _mutable.patchedTree = _newTree2;\n        _mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, _newTree2); // Root refresh\n\n        if (_flightDataPath3.length === 3) {\n          _cache.subTreeData = _subTreeData;\n          fillLazyItemsTillLeafWithHead(_cache, state.cache, _treePatch, _head);\n        } else {\n          // Copy subTreeData for the root node of the cache.\n          _cache.subTreeData = state.cache.subTreeData;\n          fillCacheWithNewSubTreeData(_cache, state.cache, _flightDataPath3);\n        }\n\n        return {\n          // Keep href as it was set during navigate / restore\n          canonicalUrl: _canonicalUrlOverrideHref2 ? _canonicalUrlOverrideHref2 : state.canonicalUrl,\n          // Keep pushRef as server-patch only causes cache/tree update.\n          pushRef: state.pushRef,\n          // Keep focusAndScrollRef as server-patch only causes cache/tree update.\n          focusAndScrollRef: state.focusAndScrollRef,\n          // Apply patched router state\n          tree: _newTree2,\n          prefetchCache: state.prefetchCache,\n          // Apply patched cache\n          cache: _cache\n        };\n      }\n\n    case ACTION_RESTORE:\n      {\n        var _url = action.url,\n            tree = action.tree;\n\n        var _href2 = createHrefFromUrl(_url);\n\n        return {\n          // Set canonical url\n          canonicalUrl: _href2,\n          pushRef: state.pushRef,\n          focusAndScrollRef: state.focusAndScrollRef,\n          cache: state.cache,\n          prefetchCache: state.prefetchCache,\n          // Restore provided tree\n          tree: tree\n        };\n      }\n    // TODO-APP: Add test for not scrolling to nearest layout when calling refresh.\n    // TODO-APP: Add test for startTransition(() => {router.push('/'); router.refresh();}), that case should scroll.\n\n    case ACTION_REFRESH:\n      {\n        var _cache2 = action.cache,\n            _mutable2 = action.mutable;\n        var _href3 = state.canonicalUrl;\n\n        var _isForCurrentTree = JSON.stringify(_mutable2.previousTree) === JSON.stringify(state.tree);\n\n        if (_mutable2.mpaNavigation && _isForCurrentTree) {\n          return {\n            // Set href.\n            canonicalUrl: _mutable2.canonicalUrlOverride ? _mutable2.canonicalUrlOverride : state.canonicalUrl,\n            // TODO-APP: verify mpaNavigation not being set is correct here.\n            pushRef: {\n              pendingPush: true,\n              mpaNavigation: _mutable2.mpaNavigation\n            },\n            // All navigation requires scroll and focus management to trigger.\n            focusAndScrollRef: {\n              apply: false\n            },\n            // Apply cache.\n            cache: state.cache,\n            prefetchCache: state.prefetchCache,\n            // Apply patched router state.\n            tree: state.tree\n          };\n        } // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n\n\n        if (_mutable2.patchedTree && _isForCurrentTree) {\n          return {\n            // Set href.\n            canonicalUrl: _mutable2.canonicalUrlOverride ? _mutable2.canonicalUrlOverride : _href3,\n            // set pendingPush (always false in this case).\n            pushRef: state.pushRef,\n            // Apply focus and scroll.\n            // TODO-APP: might need to disable this for Fast Refresh.\n            focusAndScrollRef: {\n              apply: false\n            },\n            cache: _cache2,\n            prefetchCache: state.prefetchCache,\n            tree: _mutable2.patchedTree\n          };\n        }\n\n        if (!_cache2.data) {\n          // Fetch data from the root of the tree.\n          _cache2.data = createRecordFromThenable((0, _appRouter).fetchServerResponse(new URL(_href3, location.origin), [state.tree[0], state.tree[1], state.tree[2], 'refetch']));\n        }\n\n        var _readRecordValue3 = readRecordValue(_cache2.data),\n            _readRecordValue4 = _slicedToArray(_readRecordValue3, 2),\n            _flightData2 = _readRecordValue4[0],\n            _canonicalUrlOverride2 = _readRecordValue4[1]; // Handle case when navigating to page in `pages` from `app`\n\n\n        if (typeof _flightData2 === 'string') {\n          return {\n            canonicalUrl: _flightData2,\n            pushRef: {\n              pendingPush: true,\n              mpaNavigation: true\n            },\n            focusAndScrollRef: {\n              apply: false\n            },\n            cache: state.cache,\n            prefetchCache: state.prefetchCache,\n            tree: state.tree\n          };\n        } // Remove cache.data as it has been resolved at this point.\n\n\n        _cache2.data = null; // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n\n        var _flightDataPath4 = _flightData2[0]; // FlightDataPath with more than two items means unexpected Flight data was returned\n\n        if (_flightDataPath4.length !== 3) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED');\n          return state;\n        } // Given the path can only have two items the items are only the router state and subTreeData for the root.\n\n\n        var _flightDataPath5 = _slicedToArray(_flightDataPath4, 3),\n            _treePatch2 = _flightDataPath5[0],\n            _subTreeData2 = _flightDataPath5[1],\n            _head2 = _flightDataPath5[2];\n\n        var _newTree3 = applyRouterStatePatchToTree( // TODO-APP: remove ''\n        [''], state.tree, _treePatch2);\n\n        if (_newTree3 === null) {\n          throw new Error('SEGMENT MISMATCH');\n        }\n\n        var _canonicalUrlOverrideHref3 = _canonicalUrlOverride2 ? createHrefFromUrl(_canonicalUrlOverride2) : undefined;\n\n        if (_canonicalUrlOverride2) {\n          _mutable2.canonicalUrlOverride = _canonicalUrlOverrideHref3;\n        }\n\n        _mutable2.previousTree = state.tree;\n        _mutable2.patchedTree = _newTree3;\n        _mutable2.mpaNavigation = isNavigatingToNewRootLayout(state.tree, _newTree3); // Set subTreeData for the root node of the cache.\n\n        _cache2.subTreeData = _subTreeData2;\n        fillLazyItemsTillLeafWithHead(_cache2, state.cache, _treePatch2, _head2);\n        return {\n          // Set href, this doesn't reuse the state.canonicalUrl as because of concurrent rendering the href might change between dispatching and applying.\n          canonicalUrl: _canonicalUrlOverrideHref3 ? _canonicalUrlOverrideHref3 : _href3,\n          // set pendingPush (always false in this case).\n          pushRef: state.pushRef,\n          // TODO-APP: might need to disable this for Fast Refresh.\n          focusAndScrollRef: {\n            apply: false\n          },\n          // Apply patched cache.\n          cache: _cache2,\n          prefetchCache: state.prefetchCache,\n          // Apply patched router state.\n          tree: _newTree3\n        };\n      }\n\n    case ACTION_PREFETCH:\n      {\n        var _url2 = action.url,\n            serverResponse = action.serverResponse;\n\n        var _serverResponse = _slicedToArray(serverResponse, 2),\n            _flightData3 = _serverResponse[0],\n            _canonicalUrlOverride3 = _serverResponse[1]; // TODO-APP: Implement prefetch for hard navigation\n\n\n        if (typeof _flightData3 === 'string') {\n          return state;\n        }\n\n        var _href4 = createHrefFromUrl(_url2); // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n\n\n        var _flightDataPath6 = _flightData3[0]; // The one before last item is the router state tree patch\n\n        var _flightDataPath6$slic = _flightDataPath6.slice(-3),\n            _flightDataPath6$slic2 = _slicedToArray(_flightDataPath6$slic, 2),\n            _treePatch3 = _flightDataPath6$slic2[0],\n            _subTreeData3 = _flightDataPath6$slic2[1]; // TODO-APP: Verify if `null` can't be returned from user code.\n        // If subTreeData is null the prefetch did not provide a component tree.\n\n\n        if (_subTreeData3 !== null) {\n          fillCacheWithPrefetchedSubTreeData(state.cache, _flightDataPath6);\n        }\n\n        var _flightSegmentPath6 = _flightDataPath6.slice(0, -3);\n\n        var _newTree4 = applyRouterStatePatchToTree( // TODO-APP: remove ''\n        [''].concat(_toConsumableArray(_flightSegmentPath6)), state.tree, _treePatch3); // Patch did not apply correctly\n\n\n        if (_newTree4 === null) {\n          return state;\n        } // Create new tree based on the flightSegmentPath and router state patch\n\n\n        state.prefetchCache.set(_href4, {\n          // Path without the last segment, router state, and the subTreeData\n          flightSegmentPath: _flightSegmentPath6,\n          // Create new tree based on the flightSegmentPath and router state patch\n          tree: _newTree4,\n          canonicalUrlOverride: _canonicalUrlOverride3\n        });\n        return state;\n      }\n    // This case should never be hit as dispatch is strongly typed.\n\n    default:\n      throw new Error('Unknown action');\n  }\n}\n\nfunction serverReducer(state, _action) {\n  return state;\n}\n\nvar reducer =  false ? 0 : clientReducer;\nexports.reducer = reducer;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlZHVjZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELHlCQUFBLEdBQTRCRSxpQkFBNUI7QUFDQUYsZUFBQSxHQUFrQkEsdUJBQUEsR0FBMEJBLDJCQUFBLEdBQThCQSxzQkFBQSxHQUF5QkEsdUJBQUEsR0FBMEJBLHNCQUFBLEdBQXlCLEtBQUssQ0FBM0o7O0FBQ0EsSUFBSVMsUUFBUSxHQUFHQyxtSEFBZjs7QUFDQSxJQUFJQyxpQkFBaUIsR0FBR0QsbUJBQU8sQ0FBQyxzR0FBRCxDQUEvQjs7QUFDQSxJQUFJRSxjQUFjLEdBQUdGLG1CQUFPLENBQUMsc0ZBQUQsQ0FBNUI7O0FBQ0EsSUFBSUcsVUFBVSxHQUFHSCxtQkFBTyxDQUFDLDhFQUFELENBQXhCO0FBQ0E7QUFDQTtBQUNBO0FBQUk7OztBQUNKLFNBQVNJLHdCQUFULENBQWtDQyxRQUFsQyxFQUE0QztFQUN4Q0EsUUFBUSxDQUFDQyxNQUFULEdBQWtCLFNBQWxCO0VBQ0FELFFBQVEsQ0FBQ0UsSUFBVCxDQUFjLFVBQUNoQixLQUFELEVBQVM7SUFDbkIsSUFBSWMsUUFBUSxDQUFDQyxNQUFULEtBQW9CLFNBQXhCLEVBQW1DO01BQy9CRCxRQUFRLENBQUNDLE1BQVQsR0FBa0IsV0FBbEI7TUFDQUQsUUFBUSxDQUFDZCxLQUFULEdBQWlCQSxLQUFqQjtJQUNIO0VBQ0osQ0FMRCxFQUtHLFVBQUNpQixHQUFELEVBQU87SUFDTixJQUFJSCxRQUFRLENBQUNDLE1BQVQsS0FBb0IsU0FBeEIsRUFBbUM7TUFDL0JELFFBQVEsQ0FBQ0MsTUFBVCxHQUFrQixVQUFsQjtNQUNBRCxRQUFRLENBQUNkLEtBQVQsR0FBaUJpQixHQUFqQjtJQUNIO0VBQ0osQ0FWRDtFQVdBLE9BQU9ILFFBQVA7QUFDSDtBQUNEO0FBQ0E7QUFDQTs7O0FBQUksU0FB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Q0w7O0lBQ0E7TUFDSSxNQUFNLElBQUlpQyxLQUFKLENBQVUsZ0JBQVYsQ0FBTjtFQTdlUjtBQStlSDs7QUFDRCxTQUFTTyxhQUFULENBQXVCeEMsS0FBdkIsRUFBOEJ5QyxPQUE5QixFQUF1QztFQUNuQyxPQUFPekMsS0FBUDtBQUNIOztBQUNELElBQU1uRyxPQUFPLEdBQUcsU0FBZ0MySSxDQUFoQyxHQUFnRHpDLGFBQWhFO0FBQ0FyRyxlQUFBLEdBQWtCRyxPQUFsQjs7QUFFQSxJQUFJLENBQUMsT0FBT0gsT0FBTyxXQUFkLEtBQTJCLFVBQTNCLElBQTBDLE9BQU9BLE9BQU8sV0FBZCxLQUEyQixRQUEzQixJQUF1Q0EsT0FBTyxXQUFQLEtBQW9CLElBQXRHLEtBQWdILE9BQU9BLE9BQU8sV0FBUCxDQUFnQmdKLFVBQXZCLEtBQXNDLFdBQTFKLEVBQXVLO0VBQ3JLbEosTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUFPLFdBQTdCLEVBQXVDLFlBQXZDLEVBQXFEO0lBQUVDLEtBQUssRUFBRTtFQUFULENBQXJEO0VBQ0FILE1BQU0sQ0FBQ21KLE1BQVAsQ0FBY2pKLE9BQU8sV0FBckIsRUFBK0JBLE9BQS9CO0VBQ0FrSixNQUFNLENBQUNsSixPQUFQLEdBQWlCQSxPQUFPLFdBQXhCO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWR1Y2VyLmpzPzczYjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZUhyZWZGcm9tVXJsID0gY3JlYXRlSHJlZkZyb21Vcmw7XG5leHBvcnRzLnJlZHVjZXIgPSBleHBvcnRzLkFDVElPTl9QUkVGRVRDSCA9IGV4cG9ydHMuQUNUSU9OX1NFUlZFUl9QQVRDSCA9IGV4cG9ydHMuQUNUSU9OX1JFU1RPUkUgPSBleHBvcnRzLkFDVElPTl9OQVZJR0FURSA9IGV4cG9ydHMuQUNUSU9OX1JFRlJFU0ggPSB2b2lkIDA7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xudmFyIF9tYXRjaFNlZ21lbnRzID0gcmVxdWlyZShcIi4vbWF0Y2gtc2VnbWVudHNcIik7XG52YXIgX2FwcFJvdXRlciA9IHJlcXVpcmUoXCIuL2FwcC1yb3V0ZXJcIik7XG4vKipcbiAqIENyZWF0ZSBkYXRhIGZldGNoaW5nIHJlY29yZCBmb3IgUHJvbWlzZS5cbiAqLyAvLyBUT0RPLUFQUDogY2hhbmdlIGBhbnlgIHRvIHR5cGUgaW5mZXJlbmNlLlxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gICAgdGhlbmFibGUuc3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgIHRoZW5hYmxlLnRoZW4oKHZhbHVlKT0+e1xuICAgICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIHRoZW5hYmxlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgICAgICAgICAgdGhlbmFibGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sIChlcnIpPT57XG4gICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgdGhlbmFibGUuc3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICAgICAgICAgIHRoZW5hYmxlLnZhbHVlID0gZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoZW5hYmxlO1xufVxuLyoqXG4gKiBSZWFkIHJlY29yZCB2YWx1ZSBvciB0aHJvdyBQcm9taXNlIGlmIGl0J3Mgbm90IHJlc29sdmVkIHlldC5cbiAqLyBmdW5jdGlvbiByZWFkUmVjb3JkVmFsdWUodGhlbmFibGUpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IGZpeCB0eXBlXG4gICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBmaXggdHlwZVxuICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdGhlbmFibGU7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlSHJlZkZyb21VcmwodXJsKSB7XG4gICAgcmV0dXJuIHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbn1cbi8qKlxuICogSW52YWxpZGF0ZSBjYWNoZSBvbmUgbGV2ZWwgZG93biBmcm9tIHRoZSByb3V0ZXIgc3RhdGUuXG4gKi8gLy8gVE9ETy1BUFA6IFZlcmlmeSBpZiB0aGlzIG5lZWRzIHRvIGJlIHJlY3Vyc2l2ZS5cbmZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIHJvdXRlclN0YXRlKSB7XG4gICAgLy8gUmVtb3ZlIHNlZ21lbnQgdGhhdCB3ZSBnb3QgZGF0YSBmb3Igc28gdGhhdCBpdCBpcyBmaWxsZWQgaW4gZHVyaW5nIHJlbmRlcmluZyBvZiBzdWJUcmVlRGF0YS5cbiAgICBmb3IoY29uc3Qga2V5IGluIHJvdXRlclN0YXRlWzFdKXtcbiAgICAgICAgY29uc3Qgc2VnbWVudEZvclBhcmFsbGVsUm91dGUgPSByb3V0ZXJTdGF0ZVsxXVtrZXldWzBdO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudEZvclBhcmFsbGVsUm91dGUpID8gc2VnbWVudEZvclBhcmFsbGVsUm91dGVbMV0gOiBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICBsZXQgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSA9IG5ldyBNYXAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSk7XG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQoa2V5LCBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKG5ld0NhY2hlLCBleGlzdGluZ0NhY2hlLCByb3V0ZXJTdGF0ZSwgaGVhZCkge1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBPYmplY3Qua2V5cyhyb3V0ZXJTdGF0ZVsxXSkubGVuZ3RoID09PSAwO1xuICAgIGlmIChpc0xhc3RTZWdtZW50KSB7XG4gICAgICAgIG5ld0NhY2hlLmhlYWQgPSBoZWFkO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbW92ZSBzZWdtZW50IHRoYXQgd2UgZ290IGRhdGEgZm9yIHNvIHRoYXQgaXQgaXMgZmlsbGVkIGluIGR1cmluZyByZW5kZXJpbmcgb2Ygc3ViVHJlZURhdGEuXG4gICAgZm9yKGNvbnN0IGtleSBpbiByb3V0ZXJTdGF0ZVsxXSl7XG4gICAgICAgIGNvbnN0IHBhcmFsbGVsUm91dGVTdGF0ZSA9IHJvdXRlclN0YXRlWzFdW2tleV07XG4gICAgICAgIGNvbnN0IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlID0gcGFyYWxsZWxSb3V0ZVN0YXRlWzBdO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudEZvclBhcmFsbGVsUm91dGUpID8gc2VnbWVudEZvclBhcmFsbGVsUm91dGVbMV0gOiBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZTtcbiAgICAgICAgaWYgKGV4aXN0aW5nQ2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUgPSBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSA9IG5ldyBNYXAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSk7XG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZS5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZS5zZXQoY2FjaGVLZXksIG5ld0NhY2hlTm9kZSk7XG4gICAgICAgICAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQobmV3Q2FjaGVOb2RlLCB1bmRlZmluZWQsIHBhcmFsbGVsUm91dGVTdGF0ZSwgaGVhZCk7XG4gICAgICAgICAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KGtleSwgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQoa2V5LCBuZXcgTWFwKFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICBuZXdDYWNoZU5vZGVcbiAgICAgICAgICAgIF1cbiAgICAgICAgXSkpO1xuICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChuZXdDYWNoZU5vZGUsIHVuZGVmaW5lZCwgcGFyYWxsZWxSb3V0ZVN0YXRlLCBoZWFkKTtcbiAgICB9XG59XG4vKipcbiAqIEZpbGwgY2FjaGUgd2l0aCBzdWJUcmVlRGF0YSBiYXNlZCBvbiBmbGlnaHREYXRhUGF0aFxuICovIGZ1bmN0aW9uIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgZmxpZ2h0RGF0YVBhdGgpIHtcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IGZsaWdodERhdGFQYXRoLmxlbmd0aCA8PSA1O1xuICAgIGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBzZWdtZW50XSA9IGZsaWdodERhdGFQYXRoO1xuICAgIGNvbnN0IHNlZ21lbnRGb3JDYWNoZSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudCkgPyBzZWdtZW50WzFdIDogc2VnbWVudDtcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKTtcbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcCk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnRGb3JDYWNoZSk7XG4gICAgaWYgKGlzTGFzdEVudHJ5KSB7XG4gICAgICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWNoaWxkQ2FjaGVOb2RlLmRhdGEgfHwgY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFksXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogZmxpZ2h0RGF0YVBhdGhbM10sXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHNlZ21lbnRzIG90aGVyIHRoYW4gdGhlIG9uZSB3ZSBnb3QgZGF0YSBmb3IgYXJlIHByZXNlcnZlZC5cbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA/IG5ldyBNYXAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcykgOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgICAgIGludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodERhdGFQYXRoWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBmbGlnaHREYXRhUGF0aFsyXSwgZmxpZ2h0RGF0YVBhdGhbNF0pO1xuICAgICAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50Rm9yQ2FjaGUsIGNoaWxkQ2FjaGVOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogY2hpbGRDYWNoZU5vZGUuc3RhdHVzLFxuICAgICAgICAgICAgZGF0YTogY2hpbGRDYWNoZU5vZGUuZGF0YSxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZENhY2hlTm9kZS5zdWJUcmVlRGF0YSxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGNoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKVxuICAgICAgICB9O1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnRGb3JDYWNoZSwgY2hpbGRDYWNoZU5vZGUpO1xuICAgIH1cbiAgICBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodERhdGFQYXRoLnNsaWNlKDIpKTtcbn1cbi8qKlxuICogRmlsbCBjYWNoZSB1cCB0byB0aGUgZW5kIG9mIHRoZSBmbGlnaHRTZWdtZW50UGF0aCwgaW52YWxpZGF0aW5nIGFueXRoaW5nIGJlbG93IGl0LlxuICovIGZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIGZsaWdodFNlZ21lbnRQYXRoKSB7XG4gICAgY29uc3QgaXNMYXN0RW50cnkgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPD0gMjtcbiAgICBjb25zdCBbcGFyYWxsZWxSb3V0ZUtleSwgc2VnbWVudF0gPSBmbGlnaHRTZWdtZW50UGF0aDtcbiAgICBjb25zdCBzZWdtZW50Rm9yQ2FjaGUgPSBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnQ7XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAgPSBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2hpbGRTZWdtZW50TWFwID0gbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghY2hpbGRTZWdtZW50TWFwIHx8IGNoaWxkU2VnbWVudE1hcCA9PT0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwID0gbmV3IE1hcChleGlzdGluZ0NoaWxkU2VnbWVudE1hcCk7XG4gICAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBjaGlsZFNlZ21lbnRNYXApO1xuICAgIH1cbiAgICAvLyBJbiBjYXNlIG9mIGxhc3QgZW50cnkgZG9uJ3QgY29weSBmdXJ0aGVyIGRvd24uXG4gICAgaWYgKGlzTGFzdEVudHJ5KSB7XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcC5kZWxldGUoc2VnbWVudEZvckNhY2hlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlID0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnRGb3JDYWNoZSk7XG4gICAgbGV0IGNoaWxkQ2FjaGVOb2RlID0gY2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50Rm9yQ2FjaGUpO1xuICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogY2hpbGRDYWNoZU5vZGUuc3RhdHVzLFxuICAgICAgICAgICAgZGF0YTogY2hpbGRDYWNoZU5vZGUuZGF0YSxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZENhY2hlTm9kZS5zdWJUcmVlRGF0YSxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGNoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKVxuICAgICAgICB9O1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnRGb3JDYWNoZSwgY2hpbGRDYWNoZU5vZGUpO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoKGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSk7XG59XG4vKipcbiAqIEZpbGwgY2FjaGUgd2l0aCBzdWJUcmVlRGF0YSBiYXNlZCBvbiBmbGlnaHREYXRhUGF0aCB0aGF0IHdhcyBwcmVmZXRjaGVkXG4gKiBUaGlzIG9wZXJhdGlvbiBpcyBhcHBlbmQtb25seSB0byB0aGUgZXhpc3RpbmcgY2FjaGUuXG4gKi8gZnVuY3Rpb24gZmlsbENhY2hlV2l0aFByZWZldGNoZWRTdWJUcmVlRGF0YShleGlzdGluZ0NhY2hlLCBmbGlnaHREYXRhUGF0aCkge1xuICAgIGNvbnN0IGlzTGFzdEVudHJ5ID0gZmxpZ2h0RGF0YVBhdGgubGVuZ3RoIDw9IDU7XG4gICAgY29uc3QgW3BhcmFsbGVsUm91dGVLZXksIHNlZ21lbnRdID0gZmxpZ2h0RGF0YVBhdGg7XG4gICAgY29uc3Qgc2VnbWVudEZvckNhY2hlID0gQXJyYXkuaXNBcnJheShzZWdtZW50KSA/IHNlZ21lbnRbMV0gOiBzZWdtZW50O1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwID0gZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBpZiAoaXNMYXN0RW50cnkpIHtcbiAgICAgICAgaWYgKCFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IGZsaWdodERhdGFQYXRoWzNdLFxuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChjaGlsZENhY2hlTm9kZSwgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0RGF0YVBhdGhbMl0sIGZsaWdodERhdGFQYXRoWzRdKTtcbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50Rm9yQ2FjaGUsIGNoaWxkQ2FjaGVOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpbGxDYWNoZVdpdGhQcmVmZXRjaGVkU3ViVHJlZURhdGEoZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0RGF0YVBhdGguc2xpY2UoMikpO1xufVxuLyoqXG4gKiBLaWNrIG9mZiBmZXRjaCBiYXNlZCBvbiB0aGUgY29tbW9uIGxheW91dCBiZXR3ZWVuIHR3byByb3V0ZXMuIEZpbGwgY2FjaGUgd2l0aCBkYXRhIHByb3BlcnR5IGhvbGRpbmcgdGhlIGluLXByb2dyZXNzIGZldGNoLlxuICovIGZ1bmN0aW9uIGZpbGxDYWNoZVdpdGhEYXRhUHJvcGVydHkobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIHNlZ21lbnRzLCBmZXRjaFJlc3BvbnNlKSB7XG4gICAgY29uc3QgaXNMYXN0RW50cnkgPSBzZWdtZW50cy5sZW5ndGggPT09IDE7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZUtleSA9ICdjaGlsZHJlbic7XG4gICAgY29uc3QgW3NlZ21lbnRdID0gc2VnbWVudHM7XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAgPSBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhaWxPcHRpbWlzdGljOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKTtcbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcCk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudCk7XG4gICAgbGV0IGNoaWxkQ2FjaGVOb2RlID0gY2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50KTtcbiAgICAvLyBJbiBjYXNlIG9mIGxhc3Qgc2VnbWVudCBzdGFydCBvZmYgdGhlIGZldGNoIGF0IHRoaXMgbGV2ZWwgYW5kIGRvbid0IGNvcHkgZnVydGhlciBkb3duLlxuICAgIGlmIChpc0xhc3RFbnRyeSkge1xuICAgICAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFjaGlsZENhY2hlTm9kZS5kYXRhIHx8IGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnQsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkRBVEFfRkVUQ0gsXG4gICAgICAgICAgICAgICAgZGF0YTogZmV0Y2hSZXNwb25zZSgpLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAvLyBTdGFydCBmZXRjaCBpbiB0aGUgcGxhY2Ugd2hlcmUgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXNuJ3QgaGF2ZSB0aGUgZGF0YSB5ZXQuXG4gICAgICAgIGlmICghY2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuREFUQV9GRVRDSCxcbiAgICAgICAgICAgICAgICBkYXRhOiBmZXRjaFJlc3BvbnNlKCksXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IGNoaWxkQ2FjaGVOb2RlLnN0YXR1cyxcbiAgICAgICAgICAgIGRhdGE6IGNoaWxkQ2FjaGVOb2RlLmRhdGEsXG4gICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRDYWNoZU5vZGUuc3ViVHJlZURhdGEsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChjaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcylcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50LCBjaGlsZENhY2hlTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5KGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBzZWdtZW50cy5zbGljZSgxKSwgZmV0Y2hSZXNwb25zZSk7XG59XG4vKipcbiAqIENyZWF0ZSBvcHRpbWlzdGljIHZlcnNpb24gb2Ygcm91dGVyIHN0YXRlIGJhc2VkIG9uIHRoZSBleGlzdGluZyByb3V0ZXIgc3RhdGUgYW5kIHNlZ21lbnRzLlxuICogVGhpcyBpcyB1c2VkIHRvIGFsbG93IHJlbmRlcmluZyBsYXlvdXQtcm91dGVycyB1cCB0aWxsIHRoZSBwb2ludCB3aGVyZSBkYXRhIGlzIG1pc3NpbmcuXG4gKi8gZnVuY3Rpb24gY3JlYXRlT3B0aW1pc3RpY1RyZWUoc2VnbWVudHMsIGZsaWdodFJvdXRlclN0YXRlLCBfaXNGaXJzdFNlZ21lbnQsIHBhcmVudFJlZmV0Y2gsIF9ocmVmKSB7XG4gICAgY29uc3QgW2V4aXN0aW5nU2VnbWVudCwgZXhpc3RpbmdQYXJhbGxlbFJvdXRlc10gPSBmbGlnaHRSb3V0ZXJTdGF0ZSB8fCBbXG4gICAgICAgIG51bGwsXG4gICAgICAgIHt9LCBcbiAgICBdO1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1swXTtcbiAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gc2VnbWVudHMubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IHNlZ21lbnRNYXRjaGVzID0gZXhpc3RpbmdTZWdtZW50ICE9PSBudWxsICYmICgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGV4aXN0aW5nU2VnbWVudCwgc2VnbWVudCk7XG4gICAgY29uc3Qgc2hvdWxkUmVmZXRjaFRoaXNMZXZlbCA9ICFmbGlnaHRSb3V0ZXJTdGF0ZSB8fCAhc2VnbWVudE1hdGNoZXM7XG4gICAgbGV0IHBhcmFsbGVsUm91dGVzID0ge307XG4gICAgaWYgKGV4aXN0aW5nU2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50TWF0Y2hlcykge1xuICAgICAgICBwYXJhbGxlbFJvdXRlcyA9IGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXM7XG4gICAgfVxuICAgIGxldCBjaGlsZFRyZWU7XG4gICAgaWYgKCFpc0xhc3RTZWdtZW50KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkSXRlbSA9IGNyZWF0ZU9wdGltaXN0aWNUcmVlKHNlZ21lbnRzLnNsaWNlKDEpLCBwYXJhbGxlbFJvdXRlcyA/IHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuIDogbnVsbCwgZmFsc2UsIHBhcmVudFJlZmV0Y2ggfHwgc2hvdWxkUmVmZXRjaFRoaXNMZXZlbCk7XG4gICAgICAgIGNoaWxkVHJlZSA9IGNoaWxkSXRlbTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW1xuICAgICAgICBzZWdtZW50LFxuICAgICAgICBfZXh0ZW5kcyh7fSwgcGFyYWxsZWxSb3V0ZXMsIGNoaWxkVHJlZSA/IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZFRyZWVcbiAgICAgICAgfSA6IHt9KSwgXG4gICAgXTtcbiAgICBpZiAoIXBhcmVudFJlZmV0Y2ggJiYgc2hvdWxkUmVmZXRjaFRoaXNMZXZlbCkge1xuICAgICAgICByZXN1bHRbM10gPSAncmVmZXRjaCc7XG4gICAgfVxuICAgIC8vIFRPRE8tQVBQOiBSZXZpc2l0XG4gICAgLy8gQWRkIHVybCBpbnRvIHRoZSB0cmVlXG4gICAgLy8gaWYgKGlzRmlyc3RTZWdtZW50KSB7XG4gICAgLy8gICByZXN1bHRbMl0gPSBocmVmXG4gICAgLy8gfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEFwcGx5IHRoZSByb3V0ZXIgc3RhdGUgZnJvbSB0aGUgRmxpZ2h0IHJlc3BvbnNlLiBDcmVhdGVzIGEgbmV3IHJvdXRlciBzdGF0ZSB0cmVlLlxuICovIGZ1bmN0aW9uIGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShmbGlnaHRTZWdtZW50UGF0aCwgZmxpZ2h0Um91dGVyU3RhdGUsIHRyZWVQYXRjaCkge1xuICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlcywgLCAsIGlzUm9vdExheW91dF0gPSBmbGlnaHRSb3V0ZXJTdGF0ZTtcbiAgICAvLyBSb290IHJlZnJlc2hcbiAgICBpZiAoZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHRyZWUgPSBbXG4gICAgICAgICAgICAuLi50cmVlUGF0Y2hcbiAgICAgICAgXTtcbiAgICAgICAgLy8gVE9ETy1BUFA6IHJldmlzaXRcbiAgICAgICAgLy8gaWYgKHVybCkge1xuICAgICAgICAvLyAgIHRyZWVbMl0gPSB1cmxcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG4gICAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIC8vIFRyZWUgcGF0aCByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgc2hvdWxkIGFsd2F5cyBtYXRjaCB1cCB3aXRoIHRoZSBjdXJyZW50IHRyZWUgaW4gdGhlIGJyb3dzZXJcbiAgICBpZiAoISgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFzdFNlZ21lbnQgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPT09IDI7XG4gICAgbGV0IHBhcmFsbGVsUm91dGVQYXRjaDtcbiAgICBpZiAobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZVBhdGNoID0gdHJlZVBhdGNoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFsbGVsUm91dGVQYXRjaCA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSwgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0sIHRyZWVQYXRjaCk7XG4gICAgICAgIGlmIChwYXJhbGxlbFJvdXRlUGF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyZWUgPSBbXG4gICAgICAgIGZsaWdodFNlZ21lbnRQYXRoWzBdLFxuICAgICAgICBfZXh0ZW5kcyh7fSwgcGFyYWxsZWxSb3V0ZXMsIHtcbiAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogcGFyYWxsZWxSb3V0ZVBhdGNoXG4gICAgICAgIH0pLCBcbiAgICBdO1xuICAgIC8vIEN1cnJlbnQgc2VnbWVudCBpcyB0aGUgcm9vdCBsYXlvdXRcbiAgICBpZiAoaXNSb290TGF5b3V0KSB7XG4gICAgICAgIHRyZWVbNF0gPSB0cnVlO1xuICAgIH1cbiAgICAvLyBUT0RPLUFQUDogUmV2aXNpdFxuICAgIC8vIGlmICh1cmwpIHtcbiAgICAvLyAgIHRyZWVbMl0gPSB1cmxcbiAgICAvLyB9XG4gICAgcmV0dXJuIHRyZWU7XG59XG5mdW5jdGlvbiBzaG91bGRIYXJkTmF2aWdhdGUoZmxpZ2h0U2VnbWVudFBhdGgsIGZsaWdodFJvdXRlclN0YXRlLCB0cmVlUGF0Y2gpIHtcbiAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXNdID0gZmxpZ2h0Um91dGVyU3RhdGU7XG4gICAgLy8gVE9ETy1BUFA6IENoZWNrIGlmIGBhc2AgY2FuIGJlIHJlcGxhY2VkLlxuICAgIGNvbnN0IFtjdXJyZW50U2VnbWVudCwgcGFyYWxsZWxSb3V0ZUtleV0gPSBmbGlnaHRTZWdtZW50UGF0aDtcbiAgICAvLyBDaGVjayBpZiBjdXJyZW50IHNlZ21lbnQgbWF0Y2hlcyB0aGUgZXhpc3Rpbmcgc2VnbWVudC5cbiAgICBpZiAoISgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICAvLyBJZiBkeW5hbWljIHBhcmFtZXRlciBpbiB0cmVlIGRvZXNuJ3QgbWF0Y2ggdXAgd2l0aCBzZWdtZW50IHBhdGggYSBoYXJkIG5hdmlnYXRpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50U2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBleGlzdGluZyBzZWdtZW50IGRpZCBub3QgbWF0Y2ggc29mdCBuYXZpZ2F0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0U2VnbWVudCA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyO1xuICAgIGlmIChsYXN0U2VnbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRIYXJkTmF2aWdhdGUoZmxpZ2h0U2VnbWVudFBhdGguc2xpY2UoMiksIHBhcmFsbGVsUm91dGVzW3BhcmFsbGVsUm91dGVLZXldLCB0cmVlUGF0Y2gpO1xufVxuZnVuY3Rpb24gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXh0VHJlZSkge1xuICAgIC8vIENvbXBhcmUgc2VnbWVudHNcbiAgICBjb25zdCBjdXJyZW50VHJlZVNlZ21lbnQgPSBjdXJyZW50VHJlZVswXTtcbiAgICBjb25zdCBuZXh0VHJlZVNlZ21lbnQgPSBuZXh0VHJlZVswXTtcbiAgICAvLyBJZiBhbnkgc2VnbWVudCBpcyBkaWZmZXJlbnQgYmVmb3JlIHdlIGZpbmQgdGhlIHJvb3QgbGF5b3V0LCB0aGUgcm9vdCBsYXlvdXQgaGFzIGNoYW5nZWQuXG4gICAgLy8gRS5nLiAvc2FtZS8oZ3JvdXAxKS9sYXlvdXQuanMgLT4gL3NhbWUvKGdyb3VwMikvbGF5b3V0LmpzXG4gICAgLy8gRmlyc3Qgc2VnbWVudCBpcyAnc2FtZScgZm9yIGJvdGgsIGtlZXAgbG9va2luZy4gKGdyb3VwMSkgY2hhbmdlZCB0byAoZ3JvdXAyKSBiZWZvcmUgdGhlIHJvb3QgbGF5b3V0IHdhcyBmb3VuZCwgaXQgbXVzdCBoYXZlIGNoYW5nZWQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFRyZWVTZWdtZW50KSAmJiBBcnJheS5pc0FycmF5KG5leHRUcmVlU2VnbWVudCkpIHtcbiAgICAgICAgLy8gQ29tcGFyZSBkeW5hbWljIHBhcmFtIG5hbWUgYW5kIHR5cGUgYnV0IGlnbm9yZSB0aGUgdmFsdWUsIGRpZmZlcmVudCB2YWx1ZXMgd291bGQgbm90IGFmZmVjdCB0aGUgY3VycmVudCByb290IGxheW91dFxuICAgICAgICAvLyAvW25hbWVdIC0gL3NsdWcxIGFuZCAvc2x1ZzIsIGJvdGggdmFsdWVzIChzbHVnMSAmIHNsdWcyKSBzdGlsbCBoYXMgdGhlIHNhbWUgbGF5b3V0IC9bbmFtZV0vbGF5b3V0LmpzXG4gICAgICAgIGlmIChjdXJyZW50VHJlZVNlZ21lbnRbMF0gIT09IG5leHRUcmVlU2VnbWVudFswXSB8fCBjdXJyZW50VHJlZVNlZ21lbnRbMl0gIT09IG5leHRUcmVlU2VnbWVudFsyXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRUcmVlU2VnbWVudCAhPT0gbmV4dFRyZWVTZWdtZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBDdXJyZW50IHRyZWUgcm9vdCBsYXlvdXQgZm91bmRcbiAgICBpZiAoY3VycmVudFRyZWVbNF0pIHtcbiAgICAgICAgLy8gSWYgdGhlIG5leHQgdHJlZSBkb2Vzbid0IGhhdmUgdGhlIHJvb3QgbGF5b3V0IGZsYWcsIGl0IG11c3QgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICByZXR1cm4gIW5leHRUcmVlWzRdO1xuICAgIH1cbiAgICAvLyBDdXJyZW50IHRyZWUgIGRpZG4ndCBoYXZlIGl0cyByb290IGxheW91dCBoZXJlLCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgICBpZiAobmV4dFRyZWVbNF0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFdlIGNhbid0IGFzc3VtZSBpdCdzIGBwYXJhbGxlbFJvdXRlcy5jaGlsZHJlbmAgaGVyZSBpbiBjYXNlIHRoZSByb290IGxheW91dCBpcyBgYXBwL0Bzb21ldGhpbmcvbGF5b3V0LmpzYFxuICAgIC8vIEJ1dCBpdCdzIG5vdCBwb3NzaWJsZSB0byBiZSBtb3JlIHRoYW4gb25lIHBhcmFsbGVsUm91dGVzIGJlZm9yZSB0aGUgcm9vdCBsYXlvdXQgaXMgZm91bmRcbiAgICAvLyBUT0RPLUFQUDogY2hhbmdlIHRvIHRyYXZlcnNlIGFsbCBwYXJhbGxlbCByb3V0ZXNcbiAgICBjb25zdCBjdXJyZW50VHJlZUNoaWxkID0gT2JqZWN0LnZhbHVlcyhjdXJyZW50VHJlZVsxXSlbMF07XG4gICAgY29uc3QgbmV4dFRyZWVDaGlsZCA9IE9iamVjdC52YWx1ZXMobmV4dFRyZWVbMV0pWzBdO1xuICAgIGlmICghY3VycmVudFRyZWVDaGlsZCB8fCAhbmV4dFRyZWVDaGlsZCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZUNoaWxkLCBuZXh0VHJlZUNoaWxkKTtcbn1cbmNvbnN0IEFDVElPTl9SRUZSRVNIID0gJ3JlZnJlc2gnO1xuZXhwb3J0cy5BQ1RJT05fUkVGUkVTSCA9IEFDVElPTl9SRUZSRVNIO1xuY29uc3QgQUNUSU9OX05BVklHQVRFID0gJ25hdmlnYXRlJztcbmV4cG9ydHMuQUNUSU9OX05BVklHQVRFID0gQUNUSU9OX05BVklHQVRFO1xuY29uc3QgQUNUSU9OX1JFU1RPUkUgPSAncmVzdG9yZSc7XG5leHBvcnRzLkFDVElPTl9SRVNUT1JFID0gQUNUSU9OX1JFU1RPUkU7XG5jb25zdCBBQ1RJT05fU0VSVkVSX1BBVENIID0gJ3NlcnZlci1wYXRjaCc7XG5leHBvcnRzLkFDVElPTl9TRVJWRVJfUEFUQ0ggPSBBQ1RJT05fU0VSVkVSX1BBVENIO1xuY29uc3QgQUNUSU9OX1BSRUZFVENIID0gJ3ByZWZldGNoJztcbmV4cG9ydHMuQUNUSU9OX1BSRUZFVENIID0gQUNUSU9OX1BSRUZFVENIO1xuLyoqXG4gKiBSZWR1Y2VyIHRoYXQgaGFuZGxlcyB0aGUgYXBwLXJvdXRlciBzdGF0ZSB1cGRhdGVzLlxuICovIGZ1bmN0aW9uIGNsaWVudFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgQUNUSU9OX05BVklHQVRFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgbmF2aWdhdGVUeXBlICwgY2FjaGUgLCBtdXRhYmxlICwgZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiAgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICwgc2VhcmNoICB9ID0gdXJsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybCh1cmwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdQdXNoID0gbmF2aWdhdGVUeXBlID09PSAncHVzaCc7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNGb3JDdXJyZW50VHJlZSA9IEpTT04uc3RyaW5naWZ5KG11dGFibGUucHJldmlvdXNUcmVlKSA9PT0gSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSk7XG4gICAgICAgICAgICAgICAgaWYgKG11dGFibGUubXBhTmF2aWdhdGlvbiAmJiBpc0ZvckN1cnJlbnRUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA/IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHZlcmlmeSBtcGFOYXZpZ2F0aW9uIG5vdCBiZWluZyBzZXQgaXMgY29ycmVjdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IG11dGFibGUubXBhTmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNvbmN1cnJlbnQgcmVuZGVyaW5nIC8gc3RyaWN0IG1vZGUgY2FzZSB3aGVyZSB0aGUgY2FjaGUgYW5kIHRyZWUgd2VyZSBhbHJlYWR5IHBvcHVsYXRlZC5cbiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZS5wYXRjaGVkVHJlZSAmJiBpc0ZvckN1cnJlbnRUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA/IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHZlcmlmeSBtcGFOYXZpZ2F0aW9uIG5vdCBiZWluZyBzZXQgaXMgY29ycmVjdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogbXV0YWJsZS51c2VFeGlzdGluZ0NhY2hlID8gc3RhdGUuY2FjaGUgOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IG11dGFibGUucGF0Y2hlZFRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZmV0Y2hWYWx1ZXMgPSBzdGF0ZS5wcmVmZXRjaENhY2hlLmdldChocmVmKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZmV0Y2hWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9uZSBiZWZvcmUgbGFzdCBpdGVtIGlzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZsaWdodFNlZ21lbnRQYXRoICwgdHJlZTogbmV3VHJlZSAsIGNhbm9uaWNhbFVybE92ZXJyaWRlICwgIH0gPSBwcmVmZXRjaFZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUucHJldmlvdXNUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG5ld1RyZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFyZE5hdmlnYXRlID0gLy8gVE9ETy1BUFA6IFJldmlzaXQgaWYgdGhpcyBpcyBjb3JyZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoICE9PSBsb2NhdGlvbi5zZWFyY2ggfHwgc2hvdWxkSGFyZE5hdmlnYXRlKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgc3RhdGUudHJlZSwgbmV3VHJlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFyZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHNlZ21lbnRzLnNsaWNlKDEpIHN0cmlwcyAnJywgd2UgY2FuIGdldCByaWQgb2YgJycgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHN1YlRyZWVEYXRhIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN0YXRlLmNhY2hlLnN1YlRyZWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoY2FjaGUsIHN0YXRlLmNhY2hlLCBmbGlnaHRTZWdtZW50UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUudXNlRXhpc3RpbmdDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA/IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHBlbmRpbmdQdXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbmF2aWdhdGlvbiByZXF1aXJlcyBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQgdG8gdHJpZ2dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogbXV0YWJsZS51c2VFeGlzdGluZ0NhY2hlID8gc3RhdGUuY2FjaGUgOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBuZXdUcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gZG9pbmcgYSBoYXJkIHB1c2ggdGhlcmUgY2FuIGJlIHR3byBjYXNlczogd2l0aCBvcHRpbWlzdGljIHRyZWUgYW5kIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAvLyBUaGUgd2l0aCBvcHRpbWlzdGljIHRyZWUgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiB0aGUgbGF5b3V0cyBoYXZlIGEgbG9hZGluZyBzdGF0ZSAobG9hZGluZy5qcylcbiAgICAgICAgICAgICAgICAvLyBUaGUgd2l0aG91dCBvcHRpbWlzdGljIHRyZWUgY2FzZSBoYXBwZW5zIHdoZW4gdGhlcmUgaXMgbm8gbG9hZGluZyBzdGF0ZSwgaW4gdGhhdCBjYXNlIHdlIHN1c3BlbmQgaW4gdGhpcyByZWR1Y2VyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiBpcyB1c2VkIGZvciBsaW5rcyB0aGF0IGhhdmUgYHByZWZldGNoPXtmYWxzZX1gLlxuICAgICAgICAgICAgICAgIGlmIChmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGZpZ3VyZSBvdXQgc29tZXRoaW5nIGJldHRlciBmb3IgaW5kZXggcGFnZXNcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXN0aWMgdHJlZSBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3B0aW1pc3RpYyB0cmVlIGlzIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IHN0YXRlIGxlYXZlIHRoYXQgZGVlcGVyIHBhcnQgb3V0IG9mIHRoZSBmZXRjaFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpbWlzdGljVHJlZSA9IGNyZWF0ZU9wdGltaXN0aWNUcmVlKHNlZ21lbnRzLCBzdGF0ZS50cmVlLCB0cnVlLCBmYWxzZSwgaHJlZik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcHkgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN0YXRlLmNhY2hlLnN1YlRyZWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IGV4aXN0aW5nIGNhY2hlIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZSBhbmQgZmlsbCBpbiBgZGF0YWAgcHJvcGVydHkgd2l0aCB0aGUgc3RhcnRlZCBkYXRhIGZldGNoLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYGRhdGFgIHByb3BlcnR5IGlzIHVzZWQgdG8gc3VzcGVuZCBpbiBsYXlvdXQtcm91dGVyIGR1cmluZyByZW5kZXIgaWYgaXQgaGFzbid0IHJlc29sdmVkIHlldCBieSB0aGUgdGltZSBpdCByZW5kZXJzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5KGNhY2hlLCBzdGF0ZS5jYWNoZSwgLy8gVE9ETy1BUFA6IHNlZ21lbnRzLnNsaWNlKDEpIHN0cmlwcyAnJywgd2UgY2FuIGdldCByaWQgb2YgJycgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMuc2xpY2UoMSksICgpPT4oMCwgX2FwcFJvdXRlcikuZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIG9wdGltaXN0aWNUcmVlKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG9wdGltaXN0aWMgZmV0Y2ggY291bGRuJ3QgaGFwcGVuIGl0IGZhbGxzIGJhY2sgdG8gdGhlIG5vbi1vcHRpbWlzdGljIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJlcyA9PSBudWxsID8gdm9pZCAwIDogcmVzLmJhaWxPcHRpbWlzdGljKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG9wdGltaXN0aWNUcmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG9wdGltaXN0aWNUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBwZW5kaW5nUHVzaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgb3B0aW1pc3RpYyB0cmVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IG9wdGltaXN0aWNUcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJlbG93IGlzIHRoZSBub3Qtb3B0aW1pc3RpYyBjYXNlLiBEYXRhIGlzIGZldGNoZWQgYXQgdGhlIHJvb3QgYW5kIHN1c3BlbmRlZCB0aGVyZSB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gaW4tZmxpZ2h0IGZldGNoIGF0IHRoZSB0b3AsIHN0YXJ0IGl0LlxuICAgICAgICAgICAgICAgIGlmICghY2FjaGUuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKCgwLCBfYXBwUm91dGVyKS5mZXRjaFNlcnZlclJlc3BvbnNlKHVybCwgc3RhdGUudHJlZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbndyYXAgY2FjaGUgZGF0YSB3aXRoIGB1c2VgIHRvIHN1c3BlbmQgaGVyZSAoaW4gdGhlIHJlZHVjZXIpIHVudGlsIHRoZSBmZXRjaCByZXNvbHZlcy5cbiAgICAgICAgICAgICAgICBjb25zdCBbZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsT3ZlcnJpZGVdID0gcmVhZFJlY29yZFZhbHVlKGNhY2hlLmRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBtcGFOYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFwcGx5IHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNhY2hlLmRhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgICAgICAgICAgY29uc3QgW3RyZWVQYXRjaCwgc3ViVHJlZURhdGEsIGhlYWRdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMpO1xuICAgICAgICAgICAgICAgIC8vIFBhdGggd2l0aG91dCB0aGUgbGFzdCBzZWdtZW50LCByb3V0ZXIgc3RhdGUsIGFuZCB0aGUgc3ViVHJlZURhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC00KTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRyZWUgYmFzZWQgb24gdGhlIGZsaWdodFNlZ21lbnRQYXRoIGFuZCByb3V0ZXIgc3RhdGUgcGF0Y2hcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICAgICAgICAgIF0sIHN0YXRlLnRyZWUsIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTRUdNRU5UIE1JU01BVENIJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gY3JlYXRlSHJlZkZyb21VcmwoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUubXBhTmF2aWdhdGlvbiA9IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChzdGF0ZS50cmVlLCBuZXdUcmVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKGNhY2hlLCBzdGF0ZS5jYWNoZSwgdHJlZVBhdGNoLCBoZWFkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHN1YlRyZWVEYXRhIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdGF0ZS5jYWNoZS5zdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgZXhpc3RpbmcgY2FjaGUgd2l0aCB0aGUgc3ViVHJlZURhdGEgYXBwbGllZC5cbiAgICAgICAgICAgICAgICAgICAgZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKGNhY2hlLCBzdGF0ZS5jYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPyBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgcGVuZGluZ1B1c2guXG4gICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgdHJlZTogbmV3VHJlZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQUNUSU9OX1NFUlZFUl9QQVRDSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZsaWdodERhdGEgLCBwcmV2aW91c1RyZWUgLCBvdmVycmlkZUNhbm9uaWNhbFVybCAsIGNhY2hlICwgbXV0YWJsZSAgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGEgZmV0Y2ggaXMgc2xvdyB0byByZXNvbHZlIGl0IGNvdWxkIGJlIHRoYXQgeW91IG5hdmlnYXRlZCBhd2F5IHdoaWxlIHRoZSByZXF1ZXN0IHdhcyBoYXBwZW5pbmcgb3IgYmVmb3JlIHRoZSByZWR1Y2VyIHJ1bnMuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIG9wdC1vdXQgb2YgYXBwbHlpbmcgdGhlIHBhdGNoIGdpdmVuIHRoYXQgdGhlIGRhdGEgY291bGQgYmUgc3RhbGUuXG4gICAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHByZXZpb3VzVHJlZSkgIT09IEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBIYW5kbGUgdHJlZSBtaXNtYXRjaFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVFJFRSBNSVNNQVRDSCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGV2ZXJ5dGhpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG11dGFibGUubXBhTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgPyBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlIDogc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHZlcmlmeSBtcGFOYXZpZ2F0aW9uIG5vdCBiZWluZyBzZXQgaXMgY29ycmVjdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IG11dGFibGUubXBhTmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNvbmN1cnJlbnQgcmVuZGVyaW5nIC8gc3RyaWN0IG1vZGUgY2FzZSB3aGVyZSB0aGUgY2FjaGUgYW5kIHRyZWUgd2VyZSBhbHJlYWR5IHBvcHVsYXRlZC5cbiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZS5wYXRjaGVkVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBocmVmIGFzIGl0IHdhcyBzZXQgZHVyaW5nIG5hdmlnYXRlIC8gcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgcHVzaFJlZiBhcyBzZXJ2ZXItcGF0Y2ggb25seSBjYXVzZXMgY2FjaGUvdHJlZSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiBzdGF0ZS5wdXNoUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBmb2N1c0FuZFNjcm9sbFJlZiBhcyBzZXJ2ZXItcGF0Y2ggb25seSBjYXVzZXMgY2FjaGUvdHJlZSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjogc3RhdGUuZm9jdXNBbmRTY3JvbGxSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogbXV0YWJsZS5wYXRjaGVkVHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGZsaWdodERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgbXBhTmF2aWdhdGlvbiBhcyB0aGlzIGlzIGEgbmF2aWdhdGlvbiB0aGF0IHRoZSBhcHAtcm91dGVyIHNob3VsZG4ndCBoYW5kbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFwcGx5IHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgc3RhdGUgaXMga2VwdCBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBzdGF0ZS50cmVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBDdXJyZW50bHkgdGhlIEZsaWdodCBkYXRhIGNhbiBvbmx5IGhhdmUgb25lIGl0ZW0gYnV0IGluIHRoZSBmdXR1cmUgaXQgY2FuIGhhdmUgbXVsdGlwbGUgcGF0aHMuXG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0RGF0YVBhdGggPSBmbGlnaHREYXRhWzBdO1xuICAgICAgICAgICAgICAgIC8vIFNsaWNlcyBvZmYgdGhlIGxhc3Qgc2VnbWVudCAod2hpY2ggaXMgYXQgLTQpIGFzIGl0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHRyZWUgeWV0XG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtNCk7XG4gICAgICAgICAgICAgICAgY29uc3QgW3RyZWVQYXRjaCwgc3ViVHJlZURhdGEsIGhlYWRdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgXSwgc3RhdGUudHJlZSwgdHJlZVBhdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NFR01FTlQgTUlTTUFUQ0gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gb3ZlcnJpZGVDYW5vbmljYWxVcmwgPyBjcmVhdGVIcmVmRnJvbVVybChvdmVycmlkZUNhbm9uaWNhbFVybCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZikge1xuICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLm1wYU5hdmlnYXRpb24gPSBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoc3RhdGUudHJlZSwgbmV3VHJlZSk7XG4gICAgICAgICAgICAgICAgLy8gUm9vdCByZWZyZXNoXG4gICAgICAgICAgICAgICAgaWYgKGZsaWdodERhdGFQYXRoLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN1YlRyZWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChjYWNoZSwgc3RhdGUuY2FjaGUsIHRyZWVQYXRjaCwgaGVhZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBzdWJUcmVlRGF0YSBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3RhdGUuY2FjaGUuc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShjYWNoZSwgc3RhdGUuY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBocmVmIGFzIGl0IHdhcyBzZXQgZHVyaW5nIG5hdmlnYXRlIC8gcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA/IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA6IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBwdXNoUmVmIGFzIHNlcnZlci1wYXRjaCBvbmx5IGNhdXNlcyBjYWNoZS90cmVlIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjogc3RhdGUucHVzaFJlZixcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBmb2N1c0FuZFNjcm9sbFJlZiBhcyBzZXJ2ZXItcGF0Y2ggb25seSBjYXVzZXMgY2FjaGUvdHJlZSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiBzdGF0ZS5mb2N1c0FuZFNjcm9sbFJlZixcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCByb3V0ZXIgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgdHJlZTogbmV3VHJlZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCBjYWNoZVxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIEFDVElPTl9SRVNUT1JFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgdHJlZSAgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gY3JlYXRlSHJlZkZyb21VcmwodXJsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgY2Fub25pY2FsIHVybFxuICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHN0YXRlLnB1c2hSZWYsXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiBzdGF0ZS5mb2N1c0FuZFNjcm9sbFJlZixcbiAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHByb3ZpZGVkIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgdHJlZTogdHJlZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8tQVBQOiBBZGQgdGVzdCBmb3Igbm90IHNjcm9sbGluZyB0byBuZWFyZXN0IGxheW91dCB3aGVuIGNhbGxpbmcgcmVmcmVzaC5cbiAgICAgICAgLy8gVE9ETy1BUFA6IEFkZCB0ZXN0IGZvciBzdGFydFRyYW5zaXRpb24oKCkgPT4ge3JvdXRlci5wdXNoKCcvJyk7IHJvdXRlci5yZWZyZXNoKCk7fSksIHRoYXQgY2FzZSBzaG91bGQgc2Nyb2xsLlxuICAgICAgICBjYXNlIEFDVElPTl9SRUZSRVNIOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUgLCBtdXRhYmxlICB9ID0gYWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBzdGF0ZS5jYW5vbmljYWxVcmw7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNGb3JDdXJyZW50VHJlZSA9IEpTT04uc3RyaW5naWZ5KG11dGFibGUucHJldmlvdXNUcmVlKSA9PT0gSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSk7XG4gICAgICAgICAgICAgICAgaWYgKG11dGFibGUubXBhTmF2aWdhdGlvbiAmJiBpc0ZvckN1cnJlbnRUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA/IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgOiBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogdmVyaWZ5IG1wYU5hdmlnYXRpb24gbm90IGJlaW5nIHNldCBpcyBjb3JyZWN0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogbXV0YWJsZS5tcGFOYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgcm91dGVyIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogc3RhdGUudHJlZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY29uY3VycmVudCByZW5kZXJpbmcgLyBzdHJpY3QgbW9kZSBjYXNlIHdoZXJlIHRoZSBjYWNoZSBhbmQgdHJlZSB3ZXJlIGFscmVhZHkgcG9wdWxhdGVkLlxuICAgICAgICAgICAgICAgIGlmIChtdXRhYmxlLnBhdGNoZWRUcmVlICYmIGlzRm9yQ3VycmVudFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgcGVuZGluZ1B1c2ggKGFsd2F5cyBmYWxzZSBpbiB0aGlzIGNhc2UpLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjogc3RhdGUucHVzaFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGZvY3VzIGFuZCBzY3JvbGwuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogbWlnaHQgbmVlZCB0byBkaXNhYmxlIHRoaXMgZm9yIEZhc3QgUmVmcmVzaC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IG11dGFibGUucGF0Y2hlZFRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuZGF0YSA9IGNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSgoMCwgX2FwcFJvdXRlcikuZmV0Y2hTZXJ2ZXJSZXNwb25zZShuZXcgVVJMKGhyZWYsIGxvY2F0aW9uLm9yaWdpbiksIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRyZWVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50cmVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudHJlZVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWZldGNoJywgXG4gICAgICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgW2ZsaWdodERhdGEsIGNhbm9uaWNhbFVybE92ZXJyaWRlXSA9IHJlYWRSZWNvcmRWYWx1ZShjYWNoZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGZsaWdodERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNhY2hlLmRhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAgICAgICAgICAgICAvLyBGbGlnaHREYXRhUGF0aCB3aXRoIG1vcmUgdGhhbiB0d28gaXRlbXMgbWVhbnMgdW5leHBlY3RlZCBGbGlnaHQgZGF0YSB3YXMgcmV0dXJuZWRcbiAgICAgICAgICAgICAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUkVGUkVTSCBGQUlMRUQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHaXZlbiB0aGUgcGF0aCBjYW4gb25seSBoYXZlIHR3byBpdGVtcyB0aGUgaXRlbXMgYXJlIG9ubHkgdGhlIHJvdXRlciBzdGF0ZSBhbmQgc3ViVHJlZURhdGEgZm9yIHRoZSByb290LlxuICAgICAgICAgICAgICAgIGNvbnN0IFt0cmVlUGF0Y2gsIHN1YlRyZWVEYXRhLCBoZWFkXSA9IGZsaWdodERhdGFQYXRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICBdLCBzdGF0ZS50cmVlLCB0cmVlUGF0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU0VHTUVOVCBNSVNNQVRDSCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUubXBhTmF2aWdhdGlvbiA9IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChzdGF0ZS50cmVlLCBuZXdUcmVlKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoY2FjaGUsIHN0YXRlLmNhY2hlLCB0cmVlUGF0Y2gsIGhlYWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLCB0aGlzIGRvZXNuJ3QgcmV1c2UgdGhlIHN0YXRlLmNhbm9uaWNhbFVybCBhcyBiZWNhdXNlIG9mIGNvbmN1cnJlbnQgcmVuZGVyaW5nIHRoZSBocmVmIG1pZ2h0IGNoYW5nZSBiZXR3ZWVuIGRpc3BhdGNoaW5nIGFuZCBhcHBseWluZy5cbiAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPyBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgcGVuZGluZ1B1c2ggKGFsd2F5cyBmYWxzZSBpbiB0aGlzIGNhc2UpLlxuICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiBzdGF0ZS5wdXNoUmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogbWlnaHQgbmVlZCB0byBkaXNhYmxlIHRoaXMgZm9yIEZhc3QgUmVmcmVzaC5cbiAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgcm91dGVyIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICB0cmVlOiBuZXdUcmVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBBQ1RJT05fUFJFRkVUQ0g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1cmwgLCBzZXJ2ZXJSZXNwb25zZSAgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBbZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsT3ZlcnJpZGVdID0gc2VydmVyUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IEltcGxlbWVudCBwcmVmZXRjaCBmb3IgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybCh1cmwpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBDdXJyZW50bHkgdGhlIEZsaWdodCBkYXRhIGNhbiBvbmx5IGhhdmUgb25lIGl0ZW0gYnV0IGluIHRoZSBmdXR1cmUgaXQgY2FuIGhhdmUgbXVsdGlwbGUgcGF0aHMuXG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0RGF0YVBhdGggPSBmbGlnaHREYXRhWzBdO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvbmUgYmVmb3JlIGxhc3QgaXRlbSBpcyB0aGUgcm91dGVyIHN0YXRlIHRyZWUgcGF0Y2hcbiAgICAgICAgICAgICAgICBjb25zdCBbdHJlZVBhdGNoLCBzdWJUcmVlRGF0YV0gPSBmbGlnaHREYXRhUGF0aC5zbGljZSgtMyk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IFZlcmlmeSBpZiBgbnVsbGAgY2FuJ3QgYmUgcmV0dXJuZWQgZnJvbSB1c2VyIGNvZGUuXG4gICAgICAgICAgICAgICAgLy8gSWYgc3ViVHJlZURhdGEgaXMgbnVsbCB0aGUgcHJlZmV0Y2ggZGlkIG5vdCBwcm92aWRlIGEgY29tcG9uZW50IHRyZWUuXG4gICAgICAgICAgICAgICAgaWYgKHN1YlRyZWVEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxDYWNoZVdpdGhQcmVmZXRjaGVkU3ViVHJlZURhdGEoc3RhdGUuY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtMyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGhcbiAgICAgICAgICAgICAgICBdLCBzdGF0ZS50cmVlLCB0cmVlUGF0Y2gpO1xuICAgICAgICAgICAgICAgIC8vIFBhdGNoIGRpZCBub3QgYXBwbHkgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRyZWUgYmFzZWQgb24gdGhlIGZsaWdodFNlZ21lbnRQYXRoIGFuZCByb3V0ZXIgc3RhdGUgcGF0Y2hcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcmVmZXRjaENhY2hlLnNldChocmVmLCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhdGggd2l0aG91dCB0aGUgbGFzdCBzZWdtZW50LCByb3V0ZXIgc3RhdGUsIGFuZCB0aGUgc3ViVHJlZURhdGFcbiAgICAgICAgICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdHJlZSBiYXNlZCBvbiB0aGUgZmxpZ2h0U2VnbWVudFBhdGggYW5kIHJvdXRlciBzdGF0ZSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICB0cmVlOiBuZXdUcmVlLFxuICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmxPdmVycmlkZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBjYXNlIHNob3VsZCBuZXZlciBiZSBoaXQgYXMgZGlzcGF0Y2ggaXMgc3Ryb25nbHkgdHlwZWQuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYWN0aW9uJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VydmVyUmVkdWNlcihzdGF0ZSwgX2FjdGlvbikge1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IHJlZHVjZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHNlcnZlclJlZHVjZXIgOiBjbGllbnRSZWR1Y2VyO1xuZXhwb3J0cy5yZWR1Y2VyID0gcmVkdWNlcjtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVIcmVmRnJvbVVybCIsInJlZHVjZXIiLCJBQ1RJT05fUFJFRkVUQ0giLCJBQ1RJT05fU0VSVkVSX1BBVENIIiwiQUNUSU9OX1JFU1RPUkUiLCJBQ1RJT05fTkFWSUdBVEUiLCJBQ1RJT05fUkVGUkVTSCIsIl9leHRlbmRzIiwicmVxdWlyZSIsIl9hcHBSb3V0ZXJDb250ZXh0IiwiX21hdGNoU2VnbWVudHMiLCJfYXBwUm91dGVyIiwiY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlIiwidGhlbmFibGUiLCJzdGF0dXMiLCJ0aGVuIiwiZXJyIiwicmVhZFJlY29yZFZhbHVlIiwidXJsIiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIiwiaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsInJvdXRlclN0YXRlIiwia2V5Iiwic2VnbWVudEZvclBhcmFsbGVsUm91dGUiLCJjYWNoZUtleSIsIkFycmF5IiwiaXNBcnJheSIsImV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUiLCJwYXJhbGxlbFJvdXRlcyIsImdldCIsInBhcmFsbGVsUm91dGVDYWNoZU5vZGUiLCJNYXAiLCJzZXQiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsImhlYWQiLCJpc0xhc3RTZWdtZW50Iiwia2V5cyIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVTdGF0ZSIsIm5ld0NhY2hlTm9kZSIsIkNhY2hlU3RhdGVzIiwiTEFaWV9JTklUSUFMSVpFRCIsImRhdGEiLCJzdWJUcmVlRGF0YSIsInVuZGVmaW5lZCIsImZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YSIsImZsaWdodERhdGFQYXRoIiwiaXNMYXN0RW50cnkiLCJwYXJhbGxlbFJvdXRlS2V5Iiwic2VnbWVudCIsInNlZ21lbnRGb3JDYWNoZSIsImV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwIiwiY2hpbGRTZWdtZW50TWFwIiwiZXhpc3RpbmdDaGlsZENhY2hlTm9kZSIsImNoaWxkQ2FjaGVOb2RlIiwiUkVBRFkiLCJzbGljZSIsImludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgiLCJmbGlnaHRTZWdtZW50UGF0aCIsImZpbGxDYWNoZVdpdGhQcmVmZXRjaGVkU3ViVHJlZURhdGEiLCJmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5Iiwic2VnbWVudHMiLCJmZXRjaFJlc3BvbnNlIiwiYmFpbE9wdGltaXN0aWMiLCJEQVRBX0ZFVENIIiwiY3JlYXRlT3B0aW1pc3RpY1RyZWUiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIl9pc0ZpcnN0U2VnbWVudCIsInBhcmVudFJlZmV0Y2giLCJfaHJlZiIsImV4aXN0aW5nU2VnbWVudCIsImV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMiLCJzZWdtZW50TWF0Y2hlcyIsIm1hdGNoU2VnbWVudCIsInNob3VsZFJlZmV0Y2hUaGlzTGV2ZWwiLCJjaGlsZFRyZWUiLCJjaGlsZEl0ZW0iLCJjaGlsZHJlbiIsInJlc3VsdCIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsInRyZWVQYXRjaCIsImlzUm9vdExheW91dCIsInRyZWUiLCJjdXJyZW50U2VnbWVudCIsImxhc3RTZWdtZW50IiwicGFyYWxsZWxSb3V0ZVBhdGNoIiwic2hvdWxkSGFyZE5hdmlnYXRlIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY3VycmVudFRyZWUiLCJuZXh0VHJlZSIsImN1cnJlbnRUcmVlU2VnbWVudCIsIm5leHRUcmVlU2VnbWVudCIsImN1cnJlbnRUcmVlQ2hpbGQiLCJ2YWx1ZXMiLCJuZXh0VHJlZUNoaWxkIiwiY2xpZW50UmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsIm5hdmlnYXRlVHlwZSIsImNhY2hlIiwibXV0YWJsZSIsImZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24iLCJocmVmIiwicGVuZGluZ1B1c2giLCJpc0ZvckN1cnJlbnRUcmVlIiwiSlNPTiIsInN0cmluZ2lmeSIsInByZXZpb3VzVHJlZSIsIm1wYU5hdmlnYXRpb24iLCJjYW5vbmljYWxVcmwiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsInB1c2hSZWYiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5IiwicHJlZmV0Y2hDYWNoZSIsInBhdGNoZWRUcmVlIiwidXNlRXhpc3RpbmdDYWNoZSIsInByZWZldGNoVmFsdWVzIiwibmV3VHJlZSIsImhhcmROYXZpZ2F0ZSIsImxvY2F0aW9uIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIiwic3BsaXQiLCJwdXNoIiwib3B0aW1pc3RpY1RyZWUiLCJyZXMiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsIkVycm9yIiwib3ZlcnJpZGVDYW5vbmljYWxVcmwiLCJjb25zb2xlIiwibG9nIiwiVVJMIiwib3JpZ2luIiwic2VydmVyUmVzcG9uc2UiLCJzZXJ2ZXJSZWR1Y2VyIiwiX2FjdGlvbiIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/reducer.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/render-from-template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\"use client\";\n\"use strict\";\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = RenderFromTemplateContext;\n\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\n\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\n\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\n\nfunction RenderFromTemplateContext() {\n  _s();\n\n  var children = (0, _react).useContext(_appRouterContext.TemplateContext);\n  return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, children);\n}\n\n_s(RenderFromTemplateContext, \"Fd1ieM0FAzMq7OA5+LlfYPV5S7Y=\");\n\n_c = RenderFromTemplateContext;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"RenderFromTemplateContext\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7OztBQUNBQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxrQkFBQSxHQUFrQkUseUJBQWxCOztBQUNBLElBQUlDLHlCQUF5QixHQUFHQyxxSkFBaEM7O0FBQ0EsSUFBSUMsTUFBTSxHQUFHRix5QkFBeUIsQ0FBQ0MsbUJBQU8sQ0FBQywrREFBRCxDQUFSLENBQXRDOztBQUNBLElBQUlFLGlCQUFpQixHQUFHRixtQkFBTyxDQUFDLHNHQUFELENBQS9COztBQUNBLFNBQVNGLHlCQUFULEdBQXFDO0VBQUE7O0VBQ2pDLElBQU1LLFFBQVEsR0FBRyxDQUFDLEdBQUdGLE1BQUosRUFBWUcsVUFBWixDQUF1QkYsaUJBQWlCLENBQUNHLGVBQXpDLENBQWpCO0VBQ0EsT0FBTyxhQUFjSixNQUFNLFdBQU4sQ0FBZUssYUFBZixDQUE2QkwsTUFBTSxXQUFOLENBQWVNLFFBQTVDLEVBQXNELElBQXRELEVBQTRESixRQUE1RCxDQUFyQjtBQUNIOztHQUhRTCx5Qjs7S0FBQUEseUI7O0FBTVQsSUFBSSxDQUFDLE9BQU9GLE9BQU8sV0FBZCxLQUEyQixVQUEzQixJQUEwQyxPQUFPQSxPQUFPLFdBQWQsS0FBMkIsUUFBM0IsSUFBdUNBLE9BQU8sV0FBUCxLQUFvQixJQUF0RyxLQUFnSCxPQUFPQSxPQUFPLFdBQVAsQ0FBZ0JZLFVBQXZCLEtBQXNDLFdBQTFKLEVBQXVLO0VBQ3JLZCxNQUFNLENBQUNDLGNBQVAsQ0FBc0JDLE9BQU8sV0FBN0IsRUFBdUMsWUFBdkMsRUFBcUQ7SUFBRUMsS0FBSyxFQUFFO0VBQVQsQ0FBckQ7RUFDQUgsTUFBTSxDQUFDZSxNQUFQLENBQWNiLE9BQU8sV0FBckIsRUFBK0JBLE9BQS9CO0VBQ0FjLE1BQU0sQ0FBQ2QsT0FBUCxHQUFpQkEsT0FBTyxXQUF4QjtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcz84ZWU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xuZnVuY3Rpb24gUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2FwcFJvdXRlckNvbnRleHQuVGVtcGxhdGVDb250ZXh0KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsInJlcXVpcmUiLCJfcmVhY3QiLCJfYXBwUm91dGVyQ29udGV4dCIsImNoaWxkcmVuIiwidXNlQ29udGV4dCIsIlRlbXBsYXRlQ29udGV4dCIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/render-from-template-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/use-reducer-with-devtools.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/use-reducer-with-devtools.js ***!
  \*******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.useReducerWithReduxDevtools = void 0;\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\");\n\nfunction normalizeRouterState(val) {\n  if (val instanceof Map) {\n    var obj = {};\n\n    var _iterator = _createForOfIteratorHelper(val.entries()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            key = _step$value[0],\n            value = _step$value[1];\n\n        if (typeof value === 'function') {\n          obj[key] = 'fn()';\n          continue;\n        }\n\n        if (typeof value === 'object' && value !== null) {\n          if (value.$$typeof) {\n            obj[key] = value.$$typeof.toString();\n            continue;\n          }\n\n          if (value._bundlerConfig) {\n            obj[key] = 'FlightData';\n            continue;\n          }\n        }\n\n        obj[key] = normalizeRouterState(value);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return obj;\n  }\n\n  if (typeof val === 'object' && val !== null) {\n    var _obj = {};\n\n    for (var _key in val) {\n      var _value = val[_key];\n\n      if (typeof _value === 'function') {\n        _obj[_key] = 'fn()';\n        continue;\n      }\n\n      if (typeof _value === 'object' && _value !== null) {\n        if (_value.$$typeof) {\n          _obj[_key] = _value.$$typeof.toString();\n          continue;\n        }\n\n        if (_value.hasOwnProperty('_bundlerConfig')) {\n          _obj[_key] = 'FlightData';\n          continue;\n        }\n      }\n\n      _obj[_key] = normalizeRouterState(_value);\n    }\n\n    return _obj;\n  }\n\n  if (Array.isArray(val)) {\n    return val.map(normalizeRouterState);\n  }\n\n  return val;\n}\n\nfunction devToolReducer(fn, ref) {\n  return function (state, action) {\n    var res = fn(state, action);\n\n    if (ref.current) {\n      ref.current.send(action, normalizeRouterState(res));\n    }\n\n    return res;\n  };\n}\n\nfunction useReducerWithReduxDevtoolsNoop(fn, initialState) {\n  _s();\n\n  var _useReducer = (0, _react).useReducer(fn, initialState),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      state = _useReducer2[0],\n      dispatch = _useReducer2[1];\n\n  return [state, dispatch, function () {}];\n}\n\n_s(useReducerWithReduxDevtoolsNoop, \"6JWkGZ32UPfojeNx+xqn8ZU8A0Q=\");\n\nfunction useReducerWithReduxDevtoolsImpl(fn, initialState) {\n  _s2();\n\n  var devtoolsConnectionRef = (0, _react).useRef();\n  var enabledRef = (0, _react).useRef();\n  (0, _react).useEffect(function () {\n    if (devtoolsConnectionRef.current || enabledRef.current === false) {\n      return;\n    }\n\n    if (enabledRef.current === undefined && typeof window.__REDUX_DEVTOOLS_EXTENSION__ === 'undefined') {\n      enabledRef.current = false;\n      return;\n    }\n\n    devtoolsConnectionRef.current = window.__REDUX_DEVTOOLS_EXTENSION__.connect({\n      instanceId: 1,\n      name: 'next-router'\n    });\n\n    if (devtoolsConnectionRef.current) {\n      devtoolsConnectionRef.current.init(normalizeRouterState(initialState));\n    }\n\n    return function () {\n      devtoolsConnectionRef.current = undefined;\n    };\n  }, [initialState]);\n\n  var _useReducer3 = (0, _react).useReducer(devToolReducer(\n  /* logReducer( */\n  fn\n  /*)*/\n  , devtoolsConnectionRef), initialState),\n      _useReducer4 = _slicedToArray(_useReducer3, 2),\n      state = _useReducer4[0],\n      dispatch = _useReducer4[1];\n\n  var sync = (0, _react).useCallback(function () {\n    if (devtoolsConnectionRef.current) {\n      devtoolsConnectionRef.current.send({\n        type: 'RENDER_SYNC'\n      }, normalizeRouterState(state));\n    }\n  }, [state]);\n  return [state, dispatch, sync];\n}\n\n_s2(useReducerWithReduxDevtoolsImpl, \"pLR6zS9fUqATAvEc1j249W8BDm8=\");\n\nvar useReducerWithReduxDevtools =  true ? useReducerWithReduxDevtoolsImpl : 0;\nexports.useReducerWithReduxDevtools = useReducerWithReduxDevtools;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3VzZS1yZWR1Y2VyLXdpdGgtZGV2dG9vbHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7Ozs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0M7QUFHQUQsbUNBQUEsR0FBc0MsS0FBSyxDQUEzQzs7QUFDQSxJQUFJRyxNQUFNLEdBQUdDLG1CQUFPLENBQUMsK0RBQUQsQ0FBcEI7O0FBQ0EsU0FBU0Msb0JBQVQsQ0FBOEJDLEdBQTlCLEVBQW1DO0VBQy9CLElBQUlBLEdBQUcsWUFBWUMsR0FBbkIsRUFBd0I7SUFDcEIsSUFBTUMsR0FBRyxHQUFHLEVBQVo7O0lBRG9CLDJDQUVPRixHQUFHLENBQUNHLE9BQUosRUFGUDtJQUFBOztJQUFBO01BRXBCLG9EQUF5QztRQUFBO1FBQUEsSUFBN0JDLEdBQTZCO1FBQUEsSUFBeEJULEtBQXdCOztRQUNyQyxJQUFJLE9BQU9BLEtBQVAsS0FBaUIsVUFBckIsRUFBaUM7VUFDN0JPLEdBQUcsQ0FBQ0UsR0FBRCxDQUFILEdBQVcsTUFBWDtVQUNBO1FBQ0g7O1FBQ0QsSUFBSSxPQUFPVCxLQUFQLEtBQWlCLFFBQWpCLElBQTZCQSxLQUFLLEtBQUssSUFBM0MsRUFBaUQ7VUFDN0MsSUFBSUEsS0FBSyxDQUFDVSxRQUFWLEVBQW9CO1lBQ2hCSCxHQUFHLENBQUNFLEdBQUQsQ0FBSCxHQUFXVCxLQUFLLENBQUNVLFFBQU4sQ0FBZUMsUUFBZixFQUFYO1lBQ0E7VUFDSDs7VUFDRCxJQUFJWCxLQUFLLENBQUNZLGNBQVYsRUFBMEI7WUFDdEJMLEdBQUcsQ0FBQ0UsR0FBRCxDQUFILEdBQVcsWUFBWDtZQUNBO1VBQ0g7UUFDSjs7UUFDREYsR0FBRyxDQUFDRSxHQUFELENBQUgsR0FBV0wsb0JBQW9CLENBQUNKLEtBQUQsQ0FBL0I7TUFDSDtJQWxCbUI7TUFBQTtJQUFBO01BQUE7SUFBQTs7SUFtQnBCLE9BQU9PLEdBQVA7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QW9CLElBQXRHLEtBQWdILE9BQU9BLE9BQU8sV0FBUCxDQUFnQjZDLFVBQXZCLEtBQXNDLFdBQTFKLEVBQXVLO0VBQ3JLL0MsTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUFPLFdBQTdCLEVBQXVDLFlBQXZDLEVBQXFEO0lBQUVDLEtBQUssRUFBRTtFQUFULENBQXJEO0VBQ0FILE1BQU0sQ0FBQ2dELE1BQVAsQ0FBYzlDLE9BQU8sV0FBckIsRUFBK0JBLE9BQS9CO0VBQ0ErQyxNQUFNLENBQUMvQyxPQUFQLEdBQWlCQSxPQUFPLFdBQXhCO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy91c2UtcmVkdWNlci13aXRoLWRldnRvb2xzLmpzPzQ1MDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiBub3JtYWxpemVSb3V0ZXJTdGF0ZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB2YWwuZW50cmllcygpKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdmbigpJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUuJCR0eXBlb2YudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5fYnVuZGxlckNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdGbGlnaHREYXRhJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW2tleV0gPSBub3JtYWxpemVSb3V0ZXJTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiB2YWwpe1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWxba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdmbigpJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUuJCR0eXBlb2YudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnX2J1bmRsZXJDb25maWcnKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdGbGlnaHREYXRhJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW2tleV0gPSBub3JtYWxpemVSb3V0ZXJTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICByZXR1cm4gdmFsLm1hcChub3JtYWxpemVSb3V0ZXJTdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBkZXZUb29sUmVkdWNlcihmbiwgcmVmKSB7XG4gICAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKT0+e1xuICAgICAgICBjb25zdCByZXMgPSBmbihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZWYuY3VycmVudC5zZW5kKGFjdGlvbiwgbm9ybWFsaXplUm91dGVyU3RhdGUocmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcChmbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSAoMCwgX3JlYWN0KS51c2VSZWR1Y2VyKGZuLCBpbml0aWFsU3RhdGUpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgKCk9Pnt9XG4gICAgXTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc0ltcGwoZm4sIGluaXRpYWxTdGF0ZSkge1xuICAgIGNvbnN0IGRldnRvb2xzQ29ubmVjdGlvblJlZiA9ICgwLCBfcmVhY3QpLnVzZVJlZigpO1xuICAgIGNvbnN0IGVuYWJsZWRSZWYgPSAoMCwgX3JlYWN0KS51c2VSZWYoKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50IHx8IGVuYWJsZWRSZWYuY3VycmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlZFJlZi5jdXJyZW50ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZW5hYmxlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQgPSB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXy5jb25uZWN0KHtcbiAgICAgICAgICAgIGluc3RhbmNlSWQ6IDEsXG4gICAgICAgICAgICBuYW1lOiAnbmV4dC1yb3V0ZXInXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50LmluaXQobm9ybWFsaXplUm91dGVyU3RhdGUoaW5pdGlhbFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGluaXRpYWxTdGF0ZVxuICAgIF0pO1xuICAgIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gKDAsIF9yZWFjdCkudXNlUmVkdWNlcihkZXZUb29sUmVkdWNlcigvKiBsb2dSZWR1Y2VyKCAqLyBmbiAvKikqLyAsIGRldnRvb2xzQ29ubmVjdGlvblJlZiksIGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3Qgc3luYyA9ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKCgpPT57XG4gICAgICAgIGlmIChkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCkge1xuICAgICAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQuc2VuZCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFTkRFUl9TWU5DJ1xuICAgICAgICAgICAgfSwgbm9ybWFsaXplUm91dGVyU3RhdGUoc3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgc3RhdGVcbiAgICBdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIHN5bmNcbiAgICBdO1xufVxuY29uc3QgdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNJbXBsIDogdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcDtcbmV4cG9ydHMudXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzID0gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtcmVkdWNlci13aXRoLWRldnRvb2xzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyIsIl9yZWFjdCIsInJlcXVpcmUiLCJub3JtYWxpemVSb3V0ZXJTdGF0ZSIsInZhbCIsIk1hcCIsIm9iaiIsImVudHJpZXMiLCJrZXkiLCIkJHR5cGVvZiIsInRvU3RyaW5nIiwiX2J1bmRsZXJDb25maWciLCJoYXNPd25Qcm9wZXJ0eSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImRldlRvb2xSZWR1Y2VyIiwiZm4iLCJyZWYiLCJzdGF0ZSIsImFjdGlvbiIsInJlcyIsImN1cnJlbnQiLCJzZW5kIiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcCIsImluaXRpYWxTdGF0ZSIsInVzZVJlZHVjZXIiLCJkaXNwYXRjaCIsInVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc0ltcGwiLCJkZXZ0b29sc0Nvbm5lY3Rpb25SZWYiLCJ1c2VSZWYiLCJlbmFibGVkUmVmIiwidXNlRWZmZWN0IiwidW5kZWZpbmVkIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyIsImNvbm5lY3QiLCJpbnN0YW5jZUlkIiwibmFtZSIsImluaXQiLCJzeW5jIiwidXNlQ2FsbGJhY2siLCJ0eXBlIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/use-reducer-with-devtools.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5CHP%5CDesktop%5Cferdinand-frontend%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Capp-router.js&modules=C%3A%5CUsers%5CHP%5CDesktop%5Cferdinand-frontend%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Clayout-router.js&modules=C%3A%5CUsers%5CHP%5CDesktop%5Cferdinand-frontend%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Crender-from-template-context.js&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);